(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{281:function(a,e,n){"use strict";n.r(e);var t=n(38),s=Object(t.a)({},function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"js-基础面试题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-基础面试题","aria-hidden":"true"}},[a._v("#")]),a._v(" js 基础面试题")]),a._v(" "),n("h2",{attrs:{id:"_1-js中使用typeof能得到哪些类型？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-js中使用typeof能得到哪些类型？","aria-hidden":"true"}},[a._v("#")]),a._v(" 1 js中使用typeof能得到哪些类型？")]),a._v(" "),n("p",[a._v("undefined、string、number、boolean、object、function")]),a._v(" "),n("h2",{attrs:{id:"_2-js中有哪些内置函数？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-js中有哪些内置函数？","aria-hidden":"true"}},[a._v("#")]),a._v(" 2 js中有哪些内置函数？")]),a._v(" "),n("p",[a._v("Object、Array、Boolean、Number、String、Function、Date、RegExp、Error")]),a._v(" "),n("h2",{attrs:{id:"_3-和-之间的区别？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-和-之间的区别？","aria-hidden":"true"}},[a._v("#")]),a._v(" 3 ==和===之间的区别？")]),a._v(" "),n("p",[a._v("==仅检查值相等，而===是一个更严格的等式判定，如果两个变量的值或类型不同，则返回false。")]),a._v(" "),n("h2",{attrs:{id:"_4-2-2-2-和-2-2-2的结果？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-2-和-2-2-2的结果？","aria-hidden":"true"}},[a._v("#")]),a._v(" 4 2 + 2 + '2' 和 '2' + 2 + 2的结果？")]),a._v(" "),n("p",[a._v("'42'和'222'")]),a._v(" "),n("h2",{attrs:{id:"_5-如何准确判断一个变量是数组类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何准确判断一个变量是数组类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 5 如何准确判断一个变量是数组类型")]),a._v(" "),n("p",[a._v("arr instanceof Array")]),a._v(" "),n("h2",{attrs:{id:"_6-split-和-join-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-split-和-join-的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 6 split() 和 join() 的区别?")]),a._v(" "),n("p",[a._v("前者是将字符串切割成数组的形式，后者是将数组转换成字符串")]),a._v(" "),n("h2",{attrs:{id:"_7-this几种不同的使用场景？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-this几种不同的使用场景？","aria-hidden":"true"}},[a._v("#")]),a._v(" 7 this几种不同的使用场景？")]),a._v(" "),n("ul",[n("li",[a._v("在构造函数中使用（构造函数本身）")]),a._v(" "),n("li",[a._v("作为对象属性时使用（调用属性的对象）")]),a._v(" "),n("li",[a._v("作为普通函数时使用（window）")]),a._v(" "),n("li",[a._v("call，apply，bind（执行的第一个参数）")])]),a._v(" "),n("h2",{attrs:{id:"_8-break和continue语句的作用？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-break和continue语句的作用？","aria-hidden":"true"}},[a._v("#")]),a._v(" 8 break和continue语句的作用？")]),a._v(" "),n("ul",[n("li",[a._v("break语句从当前循环中退出。")]),a._v(" "),n("li",[a._v("continue语句继续下一个循环语句。")])]),a._v(" "),n("h2",{attrs:{id:"_9-如何理解json？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何理解json？","aria-hidden":"true"}},[a._v("#")]),a._v(" 9 如何理解JSON？")]),a._v(" "),n("p",[a._v("JSON是JS的一个对象，也是一种数据格式，将JSON字符串转换成JSON对象 JSON.parse()，将JSON对象转换成JSON字符串 JSON.stringify()。")]),a._v(" "),n("h2",{attrs:{id:"_10-函数声明与函数表达式的区别？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-函数声明与函数表达式的区别？","aria-hidden":"true"}},[a._v("#")]),a._v(" 10 函数声明与函数表达式的区别？")]),a._v(" "),n("ul",[n("li",[a._v("在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；")]),a._v(" "),n("li",[a._v("至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。")])]),a._v(" "),n("h2",{attrs:{id:"_11-javascript中定时器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_11-javascript中定时器","aria-hidden":"true"}},[a._v("#")]),a._v(" 11 JavaScript中定时器?")]),a._v(" "),n("p",[a._v("定时器用于在设定的时间执行一段代码，或者在给定的时间间隔内重复该代码。")]),a._v(" "),n("ul",[n("li",[a._v("setTimeout（function，delay）函数用于启动在所述延迟之后调用特定功能的定时器。")]),a._v(" "),n("li",[a._v("setInterval（function，delay）函数用于在提到的延迟中重复执行给定的功能，只有在取消时才停止。")]),a._v(" "),n("li",[a._v("clearInterval（id）函数指示定时器停止。")])]),a._v(" "),n("h2",{attrs:{id:"_12"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_12","aria-hidden":"true"}},[a._v("#")]),a._v(" 12")]),a._v(" "),n("h2",{attrs:{id:"_13-js中的继承有哪些？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_13-js中的继承有哪些？","aria-hidden":"true"}},[a._v("#")]),a._v(" 13 js中的继承有哪些？")]),a._v(" "),n("ul",[n("li",[a._v("原型链继承：通过使用call、apply方法可以在新创建的对象上执行构造函数,用父类的构造函数来增加子类的实例；")]),a._v(" "),n("li",[a._v("构造函数继承：利用原型链来实现继承，超类的一个实例作为子类的原型；")]),a._v(" "),n("li",[a._v("组合继承：最常用，利用构造继承和原型链组合；")]),a._v(" "),n("li",[a._v("原型式继承：采用原型式继承并不需要定义一个类，传入参数obj,生成一个继承obj对象的对象；")]),a._v(" "),n("li",[a._v("寄生式继承：原型式继承的一种拓展，创建一个仅仅用于封装继承过程的函数，然后在内部以某种方式增强对象，最后返回对象；")]),a._v(" "),n("li",[a._v("寄生组合式继承：结合寄生式继承和组合式继承，完美实现不带两份超类属性的继承方式；")])]),a._v(" "),n("h2",{attrs:{id:"_14-请谈谈组合继承及写一个例子？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_14-请谈谈组合继承及写一个例子？","aria-hidden":"true"}},[a._v("#")]),a._v(" 14 请谈谈组合继承及写一个例子？")]),a._v(" "),n("p",[a._v("组合继承，指的是将原型链和借用构造函数的技术组合到一起, 避免了原型链和借用构造函数的缺点，融合了他们的优点，是JavaScript中最常用的继承模式。")]),a._v(" "),n("ul",[n("li",[a._v("思路是使用原型链实现对原型方法的继承，而通过借用构造函数来实现对实例属性的继承。")]),a._v(" "),n("li",[a._v("既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性。")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('function SuperType(name){\n  this.name=name;\n  this.colors=["red", "blue", "green"];\n}\nSuperType.prototype.sayName=function(){\n  alert(this.name);\n};\nfunction SubType(name, age){\n  //继承属性    使用借用构造函数实现对实例属性的继承\n  SuperType.call(this,name);\n  this.age=age;\n}\n//继承方法     使用原型链实现\nSubType.prototype=new SuperType();\nSubType.prototype.constructor=SubType;\nsubType.prototype.sayAge=function(){\n  alert(this.age);\n};\nvar instance1=new SubType("mary", 22);\ninstance1.colors.push("black");\nalert(instance1.colors);   //red,blue,green,black\ninstance1.sayName();  //mary\ninstance1.sayAge();  //22\n\nvar instance2=new SubType("greg", 25);\nalert(instance2.colors);   //red,blue,green\ninstance2.sayName();  //greg\ninstance2.sayAge();  //25\n')])])]),n("h2",{attrs:{id:"_15-下面三段程序的结果是？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_15-下面三段程序的结果是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 15 下面三段程序的结果是？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function a() {}\nvar a\nconsole.log(typeof a)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a = 1;  \nfunction test() {  \n  console.log(a);  \n  var a = 2; \n}  \ntest();\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a = 10;\nfunction a(a) {\n  console.log(a);\n  var a = 12;\n}\na(11);\n")])])]),n("ul",[n("li",[a._v("js语言本身具有预处理机制，js引擎在预处理期对所有声明的变量和函数进行处理，就是先把变量进行声明并读到内存里。")]),a._v(" "),n("li",[a._v("当变量名和函数名一致时后者会覆盖前者, 所以第一段的结果为 function；")]),a._v(" "),n("li",[a._v("而第二段程序，外面声明了全局变量a，值为1，但里面把a声明成了局部变量，函数内部的预处理顺序为先声明var a；然后console.log(a)，最后a=2；a=2这赋值步骤是在console.log(a)后面执行的，所以我们运行时就看到undefined了。如果函数里面去掉var，那么打印出来的值就是1了，然后全局变量a又被赋值为2。")]),a._v(" "),n("li",[a._v("所以第三段程序，先预处理var a；然后预处理整个a函数, 此时a的typeof为function, 接下来再给c赋值为10，即c=10，typeof c为number了; 最后在执行a(10)调用函数,当然就会报 a 不是一个函数的错误了，因为它现在是一个整型变量了。")])]),a._v(" "),n("h2",{attrs:{id:"_16-下面这段程序的结果是？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-下面这段程序的结果是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16 下面这段程序的结果是？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("for (var i = 0; i < 5; i++) {\n setTimeout(function() {\n  console.log(i);\n }, 1000);\n}\n \nconsole.log(i);\n")])])]),n("ul",[n("li",[a._v("只要你对 JS 中同步和异步代码的区别、变量作用域、闭包等概念有正确的理解，就知道正确答案是5,5,5,5,5,5；")]),a._v(" "),n("li",[a._v("若用->表示其前后的两次输出之间有 1 秒，而逗号表示间隔可以忽略，结果是？ 循环执行过程中，几乎同时设置了 5 个定时器，一般情况下，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的, 所以结果是 5 -> 5,5,5,5,5；")]),a._v(" "),n("li",[a._v("如果期望代码的输出变成：5 -> 0,1,2,3,4，该怎么改造代码？ 巧妙的利用 IIFE（声明即执行的函数表达式）来解决闭包造成的问题, 相当于把i赋值\b给了j这个局部变量:"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("for (var i = 0; i < 5; i++) {\n(function(j) { \n  setTimeout(function() {\n  console.log(j);\n  }, 1000);\n})(i);\n}\nconsole.log(i);\n")])])])]),a._v(" "),n("li",[a._v("有没有更符合直觉的做法？ 利用 JS 中基本类型的参数传递是按值传递的特征, 对循环体稍做手脚，让负责输出的那段代码能拿到每次循环的 i 值即可:"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var print = function (i) {\nsetTimeout(function() {\n  console.log(i);\n}, 1000);\n};\nfor (var i = 0; i < 5; i++) {\n  print(i); // 传递到 print 的 i\b 值被复制了\n}\nconsole.log(i);\n")])])])]),a._v(" "),n("li",[a._v("如果期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("for (var i = 0; i < 5; i++) {\n  (function(j) {\n    setTimeout(function() {\n    console.log(j);\n    }, 1000 * j)); // 这里修改 0~4 的定时器时间\n  })(i);\n}\n\nsetTimeout(function() { // 这里增加定时器，超时设置为 5 秒\n  console.log(i);\n}, 1000 * i);\n")])])])]),a._v(" "),n("li",[a._v("有没有基于ES6 Promise 的解决方案 ?"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("const tasks = [];\nfor (var i = 0; i < 5; i++) { \n  ((j) => {\n    tasks.push(new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(j);\n      resolve(); // 一定要 resolve\n    }, 1000 * j); \n    }));\n  })(i);\n}\n\nPromise.all(tasks).then(() => {\n  setTimeout(() => {\n    console.log( i);\n  }, 1000); // 只需把超时设置为 1 秒\n});\n")])])])]),a._v(" "),n("li",[a._v("把上面 i 的声明改成 let，怎么做？"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("const tasks = [];\nfor (let i = 0; i < 5; i++) { \n  tasks.push(new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(j);\n      resolve(); // 一定要 resolve\n    }, 1000 * j); \n  }));\n}\n\nPromise.all(tasks).then(() => {\n  setTimeout(() => {\n    console.log( i);\n  }, 1000); // 只需把超时设置为 1 秒\n});\n")])])])]),a._v(" "),n("li",[a._v("有没有代码层次更好的做法？"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("const tasks = []; // 存放异步操作的 Promise\nconst print = (i) => new Promise((resolve) => {\n  setTimeout(() => {\n    console.log(i);\n    resolve();\n  }, 1000 * i);\n});\n\n// 获得全部的异步操作\nfor (var i = 0; i < 5; i++) {\n  tasks.push(print(i));\n}\n\n// 输出最后的 i\nPromise.all(tasks).then(() => {\n  setTimeout(() => {\n    console.log(i);\n  }, 1000);\n});\n")])])])]),a._v(" "),n("li",[a._v("如何使用 ES7 中的 async await 特性来让这段代码变的更简洁？"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  const sleep = (t) => new Promise((resolve) => {\n    setTimeout(resolve, t);\n  });\n  \n  (async () => { \n    for (var i = 0; i < 5; i++) {\n      await sleep(1000);\n      console.log(i);\n    }\n    await sleep(1000);\n    console.log(i);\n  })();\n")])])])]),a._v(" "),n("li",[a._v("还能优化吗？"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  const sleep = (t) => new Promise((resolve) => {\n    setTimeout(resolve, t);\n  });\n  \n  const print = async () => { \n    for (let i = 0; i <= 5; i++) {\n      await sleep(1000);\n      console.log(i);\n    }\n  };\n\n  print();\n")])])])])])])},[],!1,null,null,null);e.default=s.exports}}]);