(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{271:function(t,a,r){"use strict";r.r(a);var e=r(38),_=Object(e.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"二十二至二十五章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二十二至二十五章","aria-hidden":"true"}},[t._v("#")]),t._v(" 二十二至二十五章")]),t._v(" "),r("h2",{attrs:{id:"_22-1-为何js使用函数指针非常简单？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-1-为何js使用函数指针非常简单？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.1 为何JS使用函数指针非常简单？")]),t._v(" "),r("p",[t._v("因为在js中，所有的函数都是对象")]),t._v(" "),r("h2",{attrs:{id:"_22-2-在安全类型检测中，为何使用tostring-能保证返回一致的值？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-2-在安全类型检测中，为何使用tostring-能保证返回一致的值？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.2 在安全类型检测中，为何使用toString()能保证返回一致的值？")]),t._v(" "),r("p",[t._v("因为原生数组或函数的构造函数名与全局作用域无关")]),t._v(" "),r("h2",{attrs:{id:"_22-3-为何在web开发中区分原生与非原生对象非常重要？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-3-为何在web开发中区分原生与非原生对象非常重要？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.3 为何在web开发中区分原生与非原生对象非常重要？")]),t._v(" "),r("p",[t._v("确切知道某个对象有哪些功能")]),t._v(" "),r("h2",{attrs:{id:"_22-4-当使用new调用时，构造函数内用到的this对象会指向哪？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-4-当使用new调用时，构造函数内用到的this对象会指向哪？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.4 当使用new调用时，构造函数内用到的this对象会指向哪？")]),t._v(" "),r("p",[t._v("新创建的对象实例")]),t._v(" "),r("h2",{attrs:{id:"_22-5-当没有使用new操作符调用构造函数时，会有何问题？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-5-当没有使用new操作符调用构造函数时，会有何问题？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.5 当没有使用new操作符调用构造函数时，会有何问题？")]),t._v(" "),r("p",[t._v("由于该this对象是运行时绑定，this会映射到全局对象上，导致错误对象属性的意外增加")]),t._v(" "),r("h2",{attrs:{id:"_22-6-如何创建作用域安全的构造函数？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-6-如何创建作用域安全的构造函数？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.6 如何创建作用域安全的构造函数？")]),t._v(" "),r("p",[t._v("在进行任何更改之前，首先确认this对象是正确类型的实例，如果不是，那么会创建新的实例并返回，避免了在全局对象上意外设置属性")]),t._v(" "),r("h2",{attrs:{id:"_22-7-作用域安全的构造函数存在什么潜在问题？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-7-作用域安全的构造函数存在什么潜在问题？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.7 作用域安全的构造函数存在什么潜在问题？")]),t._v(" "),r("p",[t._v("实现了作用域安全后，就相当于锁定了调用构造函数的环境，如果使用构造函数窃取模式继承且不使用原型链继承，这个继承很可能被破坏；")]),t._v(" "),r("h2",{attrs:{id:"_22-8-惰性载入的技巧用来干啥"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-8-惰性载入的技巧用来干啥","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.8 惰性载入的技巧用来干啥?")]),t._v(" "),r("p",[t._v("让代码运行得更快，比如存在大量if语句的代码块，即使只有一个if语句，也比没有if语句的慢；")]),t._v(" "),r("h2",{attrs:{id:"_22-9-实现惰性载入的技巧有？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-9-实现惰性载入的技巧有？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.9 实现惰性载入的技巧有？")]),t._v(" "),r("p",[t._v("第一种是在函数在被调用时再处理函数，在第一次调用过程中，该函数会被覆盖为另一个按合适方式执行的函数；第二种为在声明函数时就指定适当的函数，基于自执行匿名函数；")]),t._v(" "),r("h2",{attrs:{id:"_22-10-绑定函数一般在什么场景使用？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-10-绑定函数一般在什么场景使用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.10 绑定函数一般在什么场景使用？")]),t._v(" "),r("p",[t._v("回调函数，事件处理程序以及setTimeout()和setInterval()，以便将函数作为变量传递时保留代码执行的环境；function bind(fn, context) { return function () { return fn.apply(context, arguments);};}")]),t._v(" "),r("h2",{attrs:{id:"_22-11-为何只有在必要时使用函数绑定？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-11-为何只有在必要时使用函数绑定？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.11 为何只有在必要时使用函数绑定？")]),t._v(" "),r("p",[t._v("因为被绑定的函数与普通函数相比，会有更多的开销，比如需要更多的内存，也因为多重调用会慢一些；")]),t._v(" "),r("h2",{attrs:{id:"_22-12-函数柯里化的作用是？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-12-函数柯里化的作用是？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.12 函数柯里化的作用是？")]),t._v(" "),r("p",[t._v("用于创建已经设置好了的一个或多个参数的函数；")]),t._v(" "),r("h2",{attrs:{id:"_22-13-函数柯里化和函数绑定的异同？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-13-函数柯里化和函数绑定的异同？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.13 函数柯里化和函数绑定的异同？")]),t._v(" "),r("p",[t._v("都使用一个闭包返回一个函数，而柯里化中函数被调用时，返回函数还需要设置一些传入的参数；")]),t._v(" "),r("h2",{attrs:{id:"_22-14-为何js共享的本质让开发者头疼？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-14-为何js共享的本质让开发者头疼？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.14 为何js共享的本质让开发者头疼？")]),t._v(" "),r("p",[t._v("任何任何对象都可以被同一运行环境的代码改变，开发人员很可能意外的修改别人的代码，甚至用不兼容的功能重写原生对象")]),t._v(" "),r("h2",{attrs:{id:"_22-15-不可扩展对象、密封对象和冻结对象的区别？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-15-不可扩展对象、密封对象和冻结对象的区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.15 不可扩展对象、密封对象和冻结对象的区别？")]),t._v(" "),r("p",[t._v("调用了Object.preventExtensions()方法后，就不可以对该对象添加新的属性和方法了；\n而调用了Object.seal()方法后，不仅不可扩展，而且不能删除该对象原有的属性和方法；\n最严格的防篡改级别是冻结对象，调用了Object.freeze()方法后，不仅不能扩展和删除，甚至修改该对象的已有属性和方法都可以，只能去读。")]),t._v(" "),r("h2",{attrs:{id:"_22-16-关于定时器需要记住最重要的事情是？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-16-关于定时器需要记住最重要的事情是？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.16 关于定时器需要记住最重要的事情是？")]),t._v(" "),r("p",[t._v("指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码")]),t._v(" "),r("h2",{attrs:{id:"_22-17-为何浏览器要限制js能控制的内存大小和处理器时间？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-17-为何浏览器要限制js能控制的内存大小和处理器时间？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.17 为何浏览器要限制JS能控制的内存大小和处理器时间？")]),t._v(" "),r("p",[t._v("防止恶意的web程序吧计算机或者手机搞挂了")]),t._v(" "),r("h2",{attrs:{id:"_22-18-造成脚本长时间运行得原因有？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-18-造成脚本长时间运行得原因有？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.18 造成脚本长时间运行得原因有？")]),t._v(" "),r("p",[t._v("一是过长的或过深嵌套的函数调用；二是进行大量处理的循环；")]),t._v(" "),r("h2",{attrs:{id:"_22-19-函数节流背后的基本思想是？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-19-函数节流背后的基本思想是？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.19 函数节流背后的基本思想是？")]),t._v(" "),r("p",[t._v("某些代码不可以在没有简断的情况下连续重复执行：\nfunction throttle(method, context) {\nclearTimeout(method.tId);\nmethod.tId = setTimeout( fuction() {\nmethod.call(context);\n}, 100);\n}  如果没有纯context，则默认子全局环境下执行。")]),t._v(" "),r("h2",{attrs:{id:"_22-20-为何当代码中存在多个部分在特定时刻相互交互时，自定义事件非常有用？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_22-20-为何当代码中存在多个部分在特定时刻相互交互时，自定义事件非常有用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.20 为何当代码中存在多个部分在特定时刻相互交互时，自定义事件非常有用？")]),t._v(" "),r("p",[t._v("使用自定义对象有助于解耦相关对象，保持功能隔绝；")]),t._v(" "),r("h2",{attrs:{id:"_23-1什么是离线web应用？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_23-1什么是离线web应用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 23.1什么是离线web应用？")]),t._v(" "),r("p",[t._v("设备在不能上网的情况下仍然可以运行的应用")]),t._v(" "),r("h2",{attrs:{id:"_23-2-开发离线web应用的三部曲是？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_23-2-开发离线web应用的三部曲是？","aria-hidden":"true"}},[t._v("#")]),t._v(" 23.2 开发离线web应用的三部曲是？")])])},[],!1,null,null,null);a.default=_.exports}}]);