(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{270:function(a,r,e){"use strict";e.r(r);var t=e(38),s=Object(t.a)({},function(){var a=this,r=a.$createElement,e=a._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"十六至十八章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十六至十八章","aria-hidden":"true"}},[a._v("#")]),a._v(" 十六至十八章")]),a._v(" "),e("h2",{attrs:{id:"_16-1-什么是跨文档消息传递？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-1-什么是跨文档消息传递？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.1 什么是跨文档消息传递？")]),a._v(" "),e("p",[a._v("指的是来自不同域的页面间传递消息")]),a._v(" "),e("h2",{attrs:{id:"_16-2-xdm的核心是？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-2-xdm的核心是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.2 XDM的核心是？")]),a._v(" "),e("p",[a._v("postMessage()方法，其接受两个参数，一条消息和一个表示消息接收方来自哪个域的字符串；")]),a._v(" "),e("h2",{attrs:{id:"_16-3-如果传给postmessage-方法的第二个参数是-‘，意味着什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-3-如果传给postmessage-方法的第二个参数是-‘，意味着什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.3 如果传给postMessage()方法的第二个参数是'*‘，意味着什么？")]),a._v(" "),e("p",[a._v("可以把消息发给任何域的文档")]),a._v(" "),e("h2",{attrs:{id:"_16-4-接收xmd消息时，会触发window对象的什么事件？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-4-接收xmd消息时，会触发window对象的什么事件？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.4 接收XMD消息时，会触发window对象的什么事件？")]),a._v(" "),e("p",[a._v("以异步的形式触发message事件")]),a._v(" "),e("h2",{attrs:{id:"_16-5-触发message事件后，传给onmessage处理程序的事件对象包括什么信息？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-5-触发message事件后，传给onmessage处理程序的事件对象包括什么信息？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.5 触发message事件后，传给onmessage处理程序的事件对象包括什么信息？")]),a._v(" "),e("ul",[e("li",[a._v("data 作为postMessage()第一个参数传入的字符串数据；")]),a._v(" "),e("li",[a._v("origin 发送消息文档的所在域；")]),a._v(" "),e("li",[a._v("source 发送消息文档的Window对象代理；")])]),a._v(" "),e("h2",{attrs:{id:"_16-6-为什么不同通过event-source-这个代理对象访问window的其他任何信息？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-6-为什么不同通过event-source-这个代理对象访问window的其他任何信息？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.6 为什么不同通过event.source 这个代理对象访问window的其他任何信息？")]),a._v(" "),e("p",[a._v("因为大多数情况下，event.source 这个代理对象并非真实的window对象")]),a._v(" "),e("h2",{attrs:{id:"_16-7-为何使用postmessage-，传入结构化数据时，建议先要在传入数据调用json-stringify-，在onmessage事件处理程序中调用json-parse"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-7-为何使用postmessage-，传入结构化数据时，建议先要在传入数据调用json-stringify-，在onmessage事件处理程序中调用json-parse","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.7 为何使用postMessage()，传入结构化数据时，建议先要在传入数据调用JSON.stringify()，在onmessage事件处理程序中调用JSON.parse()?")]),a._v(" "),e("p",[a._v("因为postMessage()最早第一个参数只允许传入字符串的，后来又部分浏览器支持传入结构化数据。")]),a._v(" "),e("h2",{attrs:{id:"_16-8-拖到元素时，依次触发的事件有？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-8-拖到元素时，依次触发的事件有？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.8 拖到元素时，依次触发的事件有？")]),a._v(" "),e("p",[a._v("dragstart -> drag -> dragend")]),a._v(" "),e("h2",{attrs:{id:"_16-9-当某个元素被拖动到一个有效的目标时，会依次发生的事件有？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-9-当某个元素被拖动到一个有效的目标时，会依次发生的事件有？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.9 当某个元素被拖动到一个有效的目标时，会依次发生的事件有？")]),a._v(" "),e("p",[a._v("dragenter -> dragover -> dragleave或drop")]),a._v(" "),e("h2",{attrs:{id:"_16-10-如何把任何元素变成有效的放置目标？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-10-如何把任何元素变成有效的放置目标？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.10 如何把任何元素变成有效的放置目标？")]),a._v(" "),e("p",[a._v("重写dragenter和dragover事件的默认行为")]),a._v(" "),e("h2",{attrs:{id:"_16-11-h5规范中引入datatransefer的作用是？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-11-h5规范中引入datatransefer的作用是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.11 H5规范中引入dataTransefer的作用是？")]),a._v(" "),e("p",[a._v("在拖放操作时实现数据交互")]),a._v(" "),e("h2",{attrs:{id:"_16-12-h5为所有html元素引入的dragable属性作用是？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-12-h5为所有html元素引入的dragable属性作用是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.12 H5为所有HTML元素引入的dragable属性作用是？")]),a._v(" "),e("p",[a._v("通过设置它来控制元素是否可以拖动")]),a._v(" "),e("h2",{attrs:{id:"_16-13-为何要用canplaytype检测浏览器是否支持特定媒体格式？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-13-为何要用canplaytype检测浏览器是否支持特定媒体格式？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.13 为何要用canplayType检测浏览器是否支持特定媒体格式？")]),a._v(" "),e("p",[a._v("因为并非所有浏览器支持所有的格式")]),a._v(" "),e("h2",{attrs:{id:"_16-14-历史状态管理器有啥用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-14-历史状态管理器有啥用？","aria-hidden":"true"}},[a._v("#")]),a._v(" 16.14 历史状态管理器有啥用？")]),a._v(" "),e("p",[a._v("不必卸载当前页即可修改浏览器的历史状态栈")]),a._v(" "),e("h2",{attrs:{id:"_17-1-js中处理异常的标准方式是？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-1-js中处理异常的标准方式是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 17.1 JS中处理异常的标准方式是？")]),a._v(" "),e("p",[a._v("使用try-catch语句")]),a._v(" "),e("h2",{attrs:{id:"_17-2唯一能够保证让所有浏览器都支持的错误对象属性是？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-2唯一能够保证让所有浏览器都支持的错误对象属性是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 17.2唯一能够保证让所有浏览器都支持的错误对象属性是？")]),a._v(" "),e("p",[a._v("message属性")]),a._v(" "),e("h2",{attrs:{id:"_17-3-js中ss的7中错误类型时？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-3-js中ss的7中错误类型时？","aria-hidden":"true"}},[a._v("#")]),a._v(" 17.3 JS中ß的7中错误类型时？")]),a._v(" "),e("p",[a._v("Error EvalError  RangeError  referenceError   SyntaxError  TypeError  URIError")]),a._v(" "),e("h2",{attrs:{id:"_17-4-error这个基类型的主要目的是？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-4-error这个基类型的主要目的是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 17.4 Error这个基类型的主要目的是？")]),a._v(" "),e("p",[a._v("供开发人员抛出自定义 错误")]),a._v(" "),e("h2",{attrs:{id:"_17-5-throw操作符的作用是？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-5-throw操作符的作用是？","aria-hidden":"true"}},[a._v("#")]),a._v(" 17.5  throw操作符的作用是？")]),a._v(" "),e("p",[a._v("抛出自定义的错误，必须指定一个值")])])},[],!1,null,null,null);r.default=s.exports}}]);