(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{284:function(n,e,t){"use strict";t.r(e);var o=t(38),r=Object(o.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"vue源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue源码分析","aria-hidden":"true"}},[n._v("#")]),n._v(" vue源码分析")]),n._v(" "),t("p",[n._v("对于前端技术选型以vue技术栈为核心的团队，仅仅掌握vue的使用和关注更新日志是不够的，还必须得有人去深入vue的源码，在理解的基础上，能参与源码的维护，甚至基于此进行二次开发。")]),n._v(" "),t("p",[n._v("更多详情请参考："),t("a",{attrs:{href:"http://caibaojian.com/vue-analysis/",target:"_blank",rel:"noopener noreferrer"}},[n._v("http://caibaojian.com/vue-analysis/"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"源码目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码目录","aria-hidden":"true"}},[n._v("#")]),n._v(" 源码目录")]),n._v(" "),t("p",[n._v("其源码都在 src 目录下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('src\n├── compiler        # 所有处理编译的代码：代码生成、模板解析成 AST 语法树，AST的优化等。\n├── core            # 核心部分：Vue 实例化、观察者、虚拟 DOM、内置组件、全局 API 封装、工具函数等\n├── platforms       # 处理不同平台: 两个目录入口分别打包成运行在 web 上和 weex 上对应的 Vue.js\n├── server          # 所有服务端渲染相关的逻辑：把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序\n├── sfc          # 处理.vue 文件：把 .vue 文件内容解析成一个 JS对象\n├── shared          # 定义的一些工具方法\n')])])]),t("p",[n._v("可以看到，在vue源码中，相关的逻辑都分别放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。")]),n._v(" "),t("h2",{attrs:{id:"vue-的初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-的初始化","aria-hidden":"true"}},[n._v("#")]),n._v(" Vue 的初始化")]),n._v(" "),t("p",[n._v("vue本质上就是一个用 Function 实现的 Class，在其 prototype及它本身都扩展了一系列的方法和属性。怎么理解呢？")]),n._v(" "),t("h3",{attrs:{id:"先找到入口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先找到入口","aria-hidden":"true"}},[n._v("#")]),n._v(" 先找到入口")]),n._v(" "),t("p",[n._v("当我们的代码执行 import Vue from 'vue' 的时候，我们打开node_modules目录，可以看到，其入口文件如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/* @flow */\n\nimport config from 'core/config'\nimport { warn, cached } from 'core/util/index'\nimport { mark, measure } from 'core/util/perf'\n\nimport Vue from './runtime/index'\nimport { query } from './util/index'\nimport { compileToFunctions } from './compiler/index'\nimport { shouldDecodeNewlines, shouldDecodeNewlinesForHref } from './util/compat'\n\nconst idToTemplate = cached(id => {\n  const el = query(id)\n  return el && el.innerHTML\n})\n\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile')\n      }\n\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end')\n        measure(`vue ${this._name} compile`, 'compile', 'compile end')\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el: Element): string {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    const container = document.createElement('div')\n    container.appendChild(el.cloneNode(true))\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions\n\nexport default Vue\n")])])]),t("p",[n._v("可以看到，这里这是对挂载和参数选项进行了处理，而要看vue 这类的定义，则需要进一步看 import Vue from './runtime/index' 对应的代码。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from 'core/index'\nimport config from 'core/config'\nimport { extend, noop } from 'shared/util'\nimport { mountComponent } from 'core/instance/lifecycle'\nimport { devtools, inBrowser, isChrome } from 'core/util/index'\n\nimport {\n  query,\n  mustUseProp,\n  isReservedTag,\n  isReservedAttr,\n  getTagNamespace,\n  isUnknownElement\n} from 'web/util/index'\n\nimport { patch } from './patch'\nimport platformDirectives from './directives/index'\nimport platformComponents from './components/index'\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp\nVue.config.isReservedTag = isReservedTag\nVue.config.isReservedAttr = isReservedAttr\nVue.config.getTagNamespace = getTagNamespace\nVue.config.isUnknownElement = isUnknownElement\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives)\nextend(Vue.options.components, platformComponents)\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n\n// ...\nexport default Vue\n")])])]),t("p",[n._v("显然，这个文件主要还是对 Vue 这个对象做一些扩展，要想看Vue这个类的定义，还的看 import Vue from 'core/index' 对应的代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\n\ninitGlobalAPI(Vue)\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\nexport default Vue\n")])])]),t("p",[n._v("显然，vue 类的定义，还得进一步通过 import Vue from './instance/index'的文件去看。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n")])])]),t("p",[n._v("果然不出我所料，正如开头所说的，vue实际上就是一个用 Function 实现的类。")]),n._v(" "),t("h3",{attrs:{id:"初始化过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化过程","aria-hidden":"true"}},[n._v("#")]),n._v(" 初始化过程")]),n._v(" "),t("p",[n._v("初始化全局 Vue API 是通过前面的initGlobalAPI(Vue)来实现，该方法的定义如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/* @flow */\n\nimport config from '../config'\nimport { initUse } from './use'\nimport { initMixin } from './mixin'\nimport { initExtend } from './extend'\nimport { initAssetRegisters } from './assets'\nimport { set, del } from '../observer/index'\nimport { ASSET_TYPES } from 'shared/constants'\nimport builtInComponents from '../components/index'\nimport { observe } from 'core/observer/index'\n\nimport {\n  warn,\n  extend,\n  nextTick,\n  mergeOptions,\n  defineReactive\n} from '../util/index'\n\nexport function initGlobalAPI (Vue: GlobalAPI) {\n  // config\n  const configDef = {}\n  configDef.get = () => config\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = () => {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      )\n    }\n  }\n  Object.defineProperty(Vue, 'config', configDef)\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn,\n    extend,\n    mergeOptions,\n    defineReactive\n  }\n\n  Vue.set = set\n  Vue.delete = del\n  Vue.nextTick = nextTick\n\n  // 2.6 explicit observable API\n  Vue.observable = <T>(obj: T): T => {\n    observe(obj)\n    return obj\n  }\n\n  Vue.options = Object.create(null)\n  ASSET_TYPES.forEach(type => {\n    Vue.options[type + 's'] = Object.create(null)\n  })\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue\n\n  extend(Vue.options.components, builtInComponents)\n\n  initUse(Vue)\n  initMixin(Vue)\n  initExtend(Vue)\n  initAssetRegisters(Vue)\n}\n")])])]),t("p",[n._v("从代码可以看到，整个初始化，就是给vue这个类的原型 prototype 上扩展了方法以及本身扩展全局的静态方法。")]),n._v(" "),t("h2",{attrs:{id:"new-vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new-vue","aria-hidden":"true"}},[n._v("#")]),n._v(" new Vue")]),n._v(" "),t("p",[n._v("vue的视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。")]),n._v(" "),t("p",[n._v("new 关键字在 Javascript 语言中代表实例化是一个对象，而 Vue 实际上是一个类，类在 Javascript 中是用 Function 来实现的：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function Vue (options) {\n  this._init(options)\n}\n")])])]),t("p",[n._v("Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法， 该方法在 src/core/instance/init.js 中定义:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Vue.prototype._init = function (options?: Object) {\n  const vm: Component = this\n  // a uid\n  vm._uid = uid++\n\n  let startTag, endTag\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    startTag = `vue-perf-start:${vm._uid}`\n    endTag = `vue-perf-end:${vm._uid}`\n    mark(startTag)\n  }\n\n  // a flag to avoid this being observed\n  vm._isVue = true\n  // merge options\n  if (options && options._isComponent) {\n    // optimize internal component instantiation\n    // since dynamic options merging is pretty slow, and none of the\n    // internal component options needs special treatment.\n    initInternalComponent(vm, options)\n  } else {\n    vm.$options = mergeOptions(\n      resolveConstructorOptions(vm.constructor),\n      options || {},\n      vm\n    )\n  }\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    initProxy(vm)\n  } else {\n    vm._renderProxy = vm\n  }\n  // expose real self\n  vm._self = vm\n  initLifecycle(vm)\n  initEvents(vm)\n  initRender(vm)\n  callHook(vm, 'beforeCreate')\n  initInjections(vm) // resolve injections before data/props\n  initState(vm)\n  initProvide(vm) // resolve provide after data/props\n  callHook(vm, 'created')\n\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    vm._name = formatComponentName(vm, false)\n    mark(endTag)\n    measure(`vue ${vm._name} init`, startTag, endTag)\n  }\n\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n}\n")])])]),t("p",[n._v("Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等。")]),n._v(" "),t("h2",{attrs:{id:"vue-实例的挂载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-实例的挂载","aria-hidden":"true"}},[n._v("#")]),n._v(" Vue 实例的挂载")]),n._v(" "),t("p",[n._v("Vue 中我们是通过 $mount 实例方法去挂载 vm 的，$mount 方法在多个文件中都有定义，我们看一看src/platform/web/entry-runtime-with-compiler.js 文件中，带 compiler 版本的 $mount 实现：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const mount = Vue.prototype.$mount\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile')\n      }\n\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end')\n        measure(`vue ${this._name} compile`, 'compile', 'compile end')\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n")])])]),t("p",[n._v("这段代码首先缓存了原型上的 $mount 方法，再重新定义该方法，我们先来分析这段代码。")]),n._v(" "),t("p",[n._v("首先，它对 el 做了限制，Vue 不能挂载在 body、html 这样的根节点上。")]),n._v(" "),t("p",[n._v("其次，如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。")]),n._v(" "),t("p",[n._v("最后，调用原先原型上的 $mount 方法挂载。")]),n._v(" "),t("p",[n._v("原先原型上的 $mount 方法在 src/platform/web/runtime/index.js 中定义，之所以这么设计完全是为了复用，因为它是可以被 runtime only 版本的 Vue 直接使用的：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Vue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n")])])]),t("p",[n._v("而$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted) {\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n")])])]),t("p",[n._v("mountComponent 核心就是先调用 vm._render 方法先生成虚拟 Node，再实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法，最终调用 vm._update 更新 DOM。")]),n._v(" "),t("p",[n._v("Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数。")]),n._v(" "),t("h2",{attrs:{id:"render-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#render-方法","aria-hidden":"true"}},[n._v("#")]),n._v(" _render 方法")]),n._v(" "),t("p",[n._v("真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂，而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。")]),n._v(" "),t("p",[n._v("VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。")]),n._v(" "),t("p",[n._v("由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。")]),n._v(" "),t("p",[n._v("Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Vue.prototype._render = function (): VNode {\n const vm: Component = this\n const { render, _parentVnode } = vm.$options\n\n // reset _rendered flag on slots for duplicate slot check\n if (process.env.NODE_ENV !== 'production') {\n   for (const key in vm.$slots) {\n     // $flow-disable-line\n     vm.$slots[key]._rendered = false\n   }\n }\n\n if (_parentVnode) {\n   vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject\n }\n\n // set parent vnode. this allows render functions to have access\n // to the data on the placeholder node.\n vm.$vnode = _parentVnode\n // render self\n let vnode\n try {\n   vnode = render.call(vm._renderProxy, vm.$createElement)\n } catch (e) {\n   handleError(e, vm, `render`)\n   // return error render result,\n   // or previous vnode to prevent render error causing blank component\n   /* istanbul ignore else */\n   if (process.env.NODE_ENV !== 'production') {\n     if (vm.$options.renderError) {\n       try {\n         vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n       } catch (e) {\n         handleError(e, vm, `renderError`)\n         vnode = vm._vnode\n       }\n     } else {\n       vnode = vm._vnode\n     }\n   } else {\n     vnode = vm._vnode\n   }\n }\n // return empty vnode in case the render function errored out\n if (!(vnode instanceof VNode)) {\n   if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n     warn(\n       'Multiple root nodes returned from render function. Render function ' +\n       'should return a single root node.',\n       vm\n     )\n   }\n   vnode = createEmptyVNode()\n }\n // set parent\n vnode.parent = _parentVnode\n return vnode\n}\n")])])]),t("p",[n._v("render 函数中的 createElement 方法就是 vm.$createElement 方法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export function initRender (vm: Component) {\n  // ...\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n}\n")])])]),t("p",[n._v("实际上，vm.$createElement 方法定义是在执行 initRender 方法的时候，可以看到除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。")]),n._v(" "),t("p",[n._v("vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node, 定义在 src/core/vdom/vnode.js 中的：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array<VNode>;\n  text: string | void;\n  elm: Node | void;\n  ns: string | void;\n  context: Component | void; // rendered in this component's scope\n  key: string | number | void;\n  componentOptions: VNodeComponentOptions | void;\n  componentInstance: Component | void; // component instance\n  parent: VNode | void; // component placeholder node\n\n  // strictly internal\n  raw: boolean; // contains raw HTML? (server only)\n  isStatic: boolean; // hoisted static node\n  isRootInsert: boolean; // necessary for enter transition check\n  isComment: boolean; // empty comment placeholder?\n  isCloned: boolean; // is a cloned node?\n  isOnce: boolean; // is a v-once node?\n  asyncFactory: Function | void; // async component factory function\n  asyncMeta: Object | void;\n  isAsyncPlaceholder: boolean;\n  ssrContext: Object | void;\n  fnContext: Component | void; // real context vm for functional nodes\n  fnOptions: ?ComponentOptions; // for SSR caching\n  fnScopeId: ?string; // functional scope id support\n\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array<VNode>,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions,\n    asyncFactory?: Function\n  ) {\n    this.tag = tag\n    this.data = data\n    this.children = children\n    this.text = text\n    this.elm = elm\n    this.ns = undefined\n    this.context = context\n    this.fnContext = undefined\n    this.fnOptions = undefined\n    this.fnScopeId = undefined\n    this.key = data && data.key\n    this.componentOptions = componentOptions\n    this.componentInstance = undefined\n    this.parent = undefined\n    this.raw = false\n    this.isStatic = false\n    this.isRootInsert = true\n    this.isComment = false\n    this.isCloned = false\n    this.isOnce = false\n    this.asyncFactory = asyncFactory\n    this.asyncMeta = undefined\n    this.isAsyncPlaceholder = false\n  }\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n")])])]),t("p",[n._v("可以看到，它借鉴了一个开源库 snabbdom 的实现，然后加入了一些 Vue.js 特色的东西。")]),n._v(" "),t("h2",{attrs:{id:"update-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#update-方法","aria-hidden":"true"}},[n._v("#")]),n._v(" _update 方法")]),n._v(" "),t("p",[n._v("Vue 的 _update 是实例的一个私有方法，作用是把 VNode 渲染成真实的 DOM，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候，定义在 src/core/instance/lifecycle.js 中：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  const vm: Component = this\n  const prevEl = vm.$el\n  const prevVnode = vm._vnode\n  const prevActiveInstance = activeInstance\n  activeInstance = vm\n  vm._vnode = vnode\n  // Vue.prototype.__patch__ is injected in entry points\n  // based on the rendering backend used.\n  if (!prevVnode) {\n    // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  activeInstance = prevActiveInstance\n  // update __vue__ reference\n  if (prevEl) {\n    prevEl.__vue__ = null\n  }\n  if (vm.$el) {\n    vm.$el.__vue__ = vm\n  }\n  // if parent is an HOC, update its $el as well\n  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n    vm.$parent.$el = vm.$el\n  }\n}\n")])])]),t("p",[n._v("_update 的核心就是调用 vm."),t("strong",[n._v("patch")]),n._v(" 方法, 它接收 4个参数，oldVnode 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；vnode 表示执行 _render 后返回的 VNode 的节点；hydrating 表示是否是服务端渲染；removeOnly 是给 transition-group 用的。")])])},[],!1,null,null,null);e.default=r.exports}}]);