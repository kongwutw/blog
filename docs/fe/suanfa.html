<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>常见算法 | 空无的博客</title>
    <meta name="description" content="让全栈编程更容易！">
    <link rel="icon" href="favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/blog/assets/css/0.styles.f54d1925.css" as="style"><link rel="preload" href="/blog/assets/js/app.db404420.js" as="script"><link rel="preload" href="/blog/assets/js/2.07cc4d7a.js" as="script"><link rel="preload" href="/blog/assets/js/21.91720da3.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.067c6059.js"><link rel="prefetch" href="/blog/assets/js/11.b2e97d2d.js"><link rel="prefetch" href="/blog/assets/js/12.f3b194f5.js"><link rel="prefetch" href="/blog/assets/js/13.1d46fa14.js"><link rel="prefetch" href="/blog/assets/js/14.431e1f9e.js"><link rel="prefetch" href="/blog/assets/js/15.6aab5401.js"><link rel="prefetch" href="/blog/assets/js/16.ce4a82a0.js"><link rel="prefetch" href="/blog/assets/js/17.faa86a5d.js"><link rel="prefetch" href="/blog/assets/js/18.df937046.js"><link rel="prefetch" href="/blog/assets/js/19.7cc79e8b.js"><link rel="prefetch" href="/blog/assets/js/20.88c1806d.js"><link rel="prefetch" href="/blog/assets/js/22.a45ca4e3.js"><link rel="prefetch" href="/blog/assets/js/23.0d1a9424.js"><link rel="prefetch" href="/blog/assets/js/24.f8dc3a1b.js"><link rel="prefetch" href="/blog/assets/js/25.1f6e2fdd.js"><link rel="prefetch" href="/blog/assets/js/26.c3faecd2.js"><link rel="prefetch" href="/blog/assets/js/27.139f423e.js"><link rel="prefetch" href="/blog/assets/js/28.c62a300b.js"><link rel="prefetch" href="/blog/assets/js/29.6d695ea3.js"><link rel="prefetch" href="/blog/assets/js/3.bc263a31.js"><link rel="prefetch" href="/blog/assets/js/30.71890272.js"><link rel="prefetch" href="/blog/assets/js/31.094dc6f8.js"><link rel="prefetch" href="/blog/assets/js/32.28fc139e.js"><link rel="prefetch" href="/blog/assets/js/33.0b875c4b.js"><link rel="prefetch" href="/blog/assets/js/34.966568f6.js"><link rel="prefetch" href="/blog/assets/js/35.879e924b.js"><link rel="prefetch" href="/blog/assets/js/36.e779ed30.js"><link rel="prefetch" href="/blog/assets/js/37.552d42b9.js"><link rel="prefetch" href="/blog/assets/js/38.e752d7eb.js"><link rel="prefetch" href="/blog/assets/js/39.5cfb1c3e.js"><link rel="prefetch" href="/blog/assets/js/4.e2e0255b.js"><link rel="prefetch" href="/blog/assets/js/40.3132f99e.js"><link rel="prefetch" href="/blog/assets/js/41.afd3b019.js"><link rel="prefetch" href="/blog/assets/js/42.b597878a.js"><link rel="prefetch" href="/blog/assets/js/43.422ac91e.js"><link rel="prefetch" href="/blog/assets/js/44.f0595a0f.js"><link rel="prefetch" href="/blog/assets/js/45.1c9c4e5c.js"><link rel="prefetch" href="/blog/assets/js/46.f61c2a6e.js"><link rel="prefetch" href="/blog/assets/js/47.85a2b141.js"><link rel="prefetch" href="/blog/assets/js/48.87d6c131.js"><link rel="prefetch" href="/blog/assets/js/49.06f36298.js"><link rel="prefetch" href="/blog/assets/js/5.c11c6e26.js"><link rel="prefetch" href="/blog/assets/js/50.bdb65770.js"><link rel="prefetch" href="/blog/assets/js/51.e5f04ec9.js"><link rel="prefetch" href="/blog/assets/js/52.abd02c2a.js"><link rel="prefetch" href="/blog/assets/js/53.124413f8.js"><link rel="prefetch" href="/blog/assets/js/54.17d2c69d.js"><link rel="prefetch" href="/blog/assets/js/55.926c3143.js"><link rel="prefetch" href="/blog/assets/js/56.9056faa3.js"><link rel="prefetch" href="/blog/assets/js/57.b580554f.js"><link rel="prefetch" href="/blog/assets/js/58.0fe6c4ff.js"><link rel="prefetch" href="/blog/assets/js/59.c9dedcef.js"><link rel="prefetch" href="/blog/assets/js/6.9e5d8c9e.js"><link rel="prefetch" href="/blog/assets/js/60.7994e946.js"><link rel="prefetch" href="/blog/assets/js/61.40306ba8.js"><link rel="prefetch" href="/blog/assets/js/62.10095560.js"><link rel="prefetch" href="/blog/assets/js/63.98a563bd.js"><link rel="prefetch" href="/blog/assets/js/64.3acac147.js"><link rel="prefetch" href="/blog/assets/js/65.ff6461d6.js"><link rel="prefetch" href="/blog/assets/js/66.3dd6d939.js"><link rel="prefetch" href="/blog/assets/js/67.abe72b05.js"><link rel="prefetch" href="/blog/assets/js/68.901eb929.js"><link rel="prefetch" href="/blog/assets/js/69.555bc92e.js"><link rel="prefetch" href="/blog/assets/js/7.9b93c563.js"><link rel="prefetch" href="/blog/assets/js/70.910023e2.js"><link rel="prefetch" href="/blog/assets/js/71.4e31a5f3.js"><link rel="prefetch" href="/blog/assets/js/72.f04865d2.js"><link rel="prefetch" href="/blog/assets/js/73.d9e0aa1c.js"><link rel="prefetch" href="/blog/assets/js/74.30b717b4.js"><link rel="prefetch" href="/blog/assets/js/75.7a35c8e2.js"><link rel="prefetch" href="/blog/assets/js/76.42220da8.js"><link rel="prefetch" href="/blog/assets/js/8.ab3cc639.js"><link rel="prefetch" href="/blog/assets/js/9.a9f74242.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.f54d1925.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">空无的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/jsGuide/1.html" class="nav-link">JS入门导读</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">JS高级导读</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">全栈入门</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">开发环境配置参考</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">koa+vue全栈开发实战</a></li></ul></div></div><div class="nav-item"><a href="/blog/interview/1.html" class="nav-link">面试宝典</a></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/kongwutw/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/jsGuide/1.html" class="nav-link">JS入门导读</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">JS高级导读</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">全栈入门</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">开发环境配置参考</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">koa+vue全栈开发实战</a></li></ul></div></div><div class="nav-item"><a href="/blog/interview/1.html" class="nav-link">面试宝典</a></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/kongwutw/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>大前端教程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/fe/vue.html" class="sidebar-link">vue源码分析</a></li><li><a href="/blog/fe/VueRouter.html" class="sidebar-link">VueRouter 源码</a></li><li><a href="/blog/fe/vuex.html" class="sidebar-link">Vuex源码分析</a></li><li><a href="/blog/fe/linux.html" class="sidebar-link">Linux 入门</a></li><li><a href="/blog/fe/vscode.html" class="sidebar-link">推荐 vscode</a></li><li><a href="/blog/fe/node.html" class="sidebar-link">关于nodejs</a></li><li><a href="/blog/fe/code.html" class="sidebar-link">代码规范</a></li><li><a href="/blog/fe/suanfa.html" class="active sidebar-link">常见算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#基础算法题" class="sidebar-link">基础算法题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_1-不需要借助第三个临时变量，实现两个变量的交换" class="sidebar-link">1 不需要借助第三个临时变量，实现两个变量的交换</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_2-确保字符串的每个单词首字母都大写，其余部分小写" class="sidebar-link">2 确保字符串的每个单词首字母都大写，其余部分小写</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_3-找出正整数-数组的最大差值" class="sidebar-link">3 找出正整数 数组的最大差值</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_4-清除字符串前后的空格（兼容所有浏览器）" class="sidebar-link">4 清除字符串前后的空格（兼容所有浏览器）</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_5-去掉一组整型数组中重复的值" class="sidebar-link">5 去掉一组整型数组中重复的值</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_6-翻转字符串" class="sidebar-link">6 翻转字符串</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_7-找到提供的句子中最长的单词，并计算它的长度。" class="sidebar-link">7 找到提供的句子中最长的单词，并计算它的长度。</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_8-截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用-来表示" class="sidebar-link">8 截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用...来表示</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_9-判断一个字符串中出现次数最多的字符，统计这个次数" class="sidebar-link">9 判断一个字符串中出现次数最多的字符，统计这个次数</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_10-快速排序（quick-sort）" class="sidebar-link">10 快速排序（Quick Sort）</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_11-斐波那契数列" class="sidebar-link">11 斐波那契数列</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_12-深拷贝" class="sidebar-link">12 深拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_13-防抖" class="sidebar-link">13 防抖</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_14-节流" class="sidebar-link">14 节流</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#进阶算法题" class="sidebar-link">进阶算法题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_15-js实现链表" class="sidebar-link">15 js实现链表</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_16-前端框架的diff算法" class="sidebar-link">16 前端框架的diff算法</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_17-js实现二叉树" class="sidebar-link">17 js实现二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_18-下面这段程序的结果是？" class="sidebar-link">18 下面这段程序的结果是？</a></li><li class="sidebar-sub-header"><a href="/blog/fe/suanfa.html#_19-实现发布订阅" class="sidebar-link">19 实现发布订阅</a></li></ul></li></ul></li><li><a href="/blog/fe/ngnix.html" class="sidebar-link">关于ngnix</a></li><li><a href="/blog/fe/pm2.html" class="sidebar-link">pm2 部署</a></li><li><a href="/blog/fe/ssh.html" class="sidebar-link">web安全</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="常见算法"><a href="#常见算法" aria-hidden="true" class="header-anchor">#</a> 常见算法</h1> <h2 id="基础算法题"><a href="#基础算法题" aria-hidden="true" class="header-anchor">#</a> 基础算法题</h2> <h3 id="_1-不需要借助第三个临时变量，实现两个变量的交换"><a href="#_1-不需要借助第三个临时变量，实现两个变量的交换" aria-hidden="true" class="header-anchor">#</a> 1 不需要借助第三个临时变量，实现两个变量的交换</h3> <div class="language- extra-class"><pre class="language-text"><code>function swap（a,b）{
  b = b - a;
  a = a + b;
  b = a - b;
  return [a,b];
}
</code></pre></div><p>或使用位运算实现</p> <div class="language- extra-class"><pre class="language-text"><code>function swap（a,b）{
  a = a^b
  b = a^b
  a = a^b
  return [a,b];
}
</code></pre></div><h3 id="_2-确保字符串的每个单词首字母都大写，其余部分小写"><a href="#_2-确保字符串的每个单词首字母都大写，其余部分小写" aria-hidden="true" class="header-anchor">#</a> 2 确保字符串的每个单词首字母都大写，其余部分小写</h3> <div class="language- extra-class"><pre class="language-text"><code>function titleCase(str) {
  var lstr = str.toLowerCase().split(' ');
  for(var i = 0 ; i &lt; lstr.length; i++) {
    lstr[i] = lstr[i][0].toUpperCase() + lstr[i].substring(1, lstr[i].length);
  }
  var res = lstr.join(' ');
  return res;
}
titleCase(&quot;good night&quot;); // Good Night
</code></pre></div><h3 id="_3-找出正整数-数组的最大差值"><a href="#_3-找出正整数-数组的最大差值" aria-hidden="true" class="header-anchor">#</a> 3 找出正整数 数组的最大差值</h3> <div class="language- extra-class"><pre class="language-text"><code>function getMaxPro(arr){
  var min = arr[0];
  var max = 0;
  for (var i=0;i&lt;arr.length;i++){
    var current = arr[i];
    min = Math.min(min, current);
    var res = currenr - min;
    max = Math.max(max, res);
  }
  return max;  
}
</code></pre></div><h3 id="_4-清除字符串前后的空格（兼容所有浏览器）"><a href="#_4-清除字符串前后的空格（兼容所有浏览器）" aria-hidden="true" class="header-anchor">#</a> 4 清除字符串前后的空格（兼容所有浏览器）</h3> <div class="language- extra-class"><pre class="language-text"><code>function trim(str) {
  if (str &amp; typeof str === &quot;string&quot;) {
    return str.replace(/(^s*)|(s*)$/g, ''); //去除前后空白符
  }
}
</code></pre></div><h3 id="_5-去掉一组整型数组中重复的值"><a href="#_5-去掉一组整型数组中重复的值" aria-hidden="true" class="header-anchor">#</a> 5 去掉一组整型数组中重复的值</h3> <div class="language- extra-class"><pre class="language-text"><code>let unique =  function(arr){
  let hash={};
  let data=[];
  for (let i=0;i &lt; arr.length; i++){
    if (!hash[arr[i]])  {
      hash[arr[i]] = true;
      data.push(arr[i]);
    }      
  }
  return data
}
</code></pre></div><h3 id="_6-翻转字符串"><a href="#_6-翻转字符串" aria-hidden="true" class="header-anchor">#</a> 6 翻转字符串</h3> <ul><li>split（）字符串转成数组；</li> <li>reverse()翻转数组；</li> <li>join()数组转化成字符串。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function reverseString(str){    
  return str.split('').reverse().join('');	
}
</code></pre></div><h3 id="_7-找到提供的句子中最长的单词，并计算它的长度。"><a href="#_7-找到提供的句子中最长的单词，并计算它的长度。" aria-hidden="true" class="header-anchor">#</a> 7 找到提供的句子中最长的单词，并计算它的长度。</h3> <ul><li>转化成数组；</li> <li>根据元素长度排序；</li> <li>输出最长元素并返回长度。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function findLongestString(str){
  var arr = str.split(' ');	
  var arrSort = arr.sort(function (a,b) {	   
    return b.length - a.length;
  });
  return [arrSort[0], arrSort[0].length];
}
</code></pre></div><h3 id="_8-截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用-来表示"><a href="#_8-截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用-来表示" aria-hidden="true" class="header-anchor">#</a> 8 截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用...来表示</h3> <div class="language- extra-class"><pre class="language-text"><code>function truncate(str, num){
  var trStr = str.slice(0, num);
  if (trStr.length &gt; num) {					
    return trStr.concat('...');
  } else {
    return str;
  }
}
</code></pre></div><h3 id="_9-判断一个字符串中出现次数最多的字符，统计这个次数"><a href="#_9-判断一个字符串中出现次数最多的字符，统计这个次数" aria-hidden="true" class="header-anchor">#</a> 9 判断一个字符串中出现次数最多的字符，统计这个次数</h3> <div class="language- extra-class"><pre class="language-text"><code>funcion findMaxStrCount(str) {
  var countObj = {};
  var max = '';
  for(var i = 0; i &lt; str.length; i++) {
    var cur = str[i];
    if(!countObj[cur]) {
      countObj[cur] = 0;
    } 
    countObj[cur]++;
    if(max === '' || countObj[cur] &gt; countObj[max]) { max = cur; }
  }
  return [max, countObj[max]];
}

</code></pre></div><h3 id="_10-快速排序（quick-sort）"><a href="#_10-快速排序（quick-sort）" aria-hidden="true" class="header-anchor">#</a> 10 快速排序（Quick Sort）</h3> <p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p> <div class="language- extra-class"><pre class="language-text"><code>var quickSort = function(arr) {
　if (arr.length &lt;= 1) { return arr; }
　var pivotIndex = Math.floor(arr.length / 2);
　var pivot = arr.splice(pivotIndex, 1)[0];
　var left = [];
　var right = [];
　for (var i = 0; i &lt; arr.length; i++){
　　if (arr[i] &lt; pivot) {
　　　left.push(arr[i]);
　　} else {
　　　right.push(arr[i]);
　　}
　}
　return quickSort(left).concat([pivot], quickSort(right));
};
</code></pre></div><h3 id="_11-斐波那契数列"><a href="#_11-斐波那契数列" aria-hidden="true" class="header-anchor">#</a> 11 斐波那契数列</h3> <div class="language- extra-class"><pre class="language-text"><code>function fib(n){
  if(typeof n === 'number' &amp;&amp; n &gt; 0 &amp;&amp; parseInt(n) === n ) {
    return n &lt; 2 ? 1 : fib(n-1)+fib(n-2);　
  } else {
    return '输入不合法，请输入正整数！'；
  }　　　
}
</code></pre></div><h3 id="_12-深拷贝"><a href="#_12-深拷贝" aria-hidden="true" class="header-anchor">#</a> 12 深拷贝</h3> <div class="language- extra-class"><pre class="language-text"><code>function deepCopy(obj) {
  const copyObj = obj instanceof Array ? [] : {};
  for (const o in obj) {
    if (obj.hasOwnProperty(o)) {
      if (typeof obj[o] !== 'object' || obj[o] === null) {
        copyObj[o] = obj[o];
      } else {
        copyObj[o] = deepCopy(obj[o]);
      }
    }
  }
  return copyObj;
}
</code></pre></div><h3 id="_13-防抖"><a href="#_13-防抖" aria-hidden="true" class="header-anchor">#</a> 13 防抖</h3> <div class="language- extra-class"><pre class="language-text"><code>const debounce = (fn, time) =&gt; {
  let timer = null;
  if (timer) clearTimeout(timer);
  timer = setTimeout(() =&gt; {
    fn();
  }, time);
};
</code></pre></div><h3 id="_14-节流"><a href="#_14-节流" aria-hidden="true" class="header-anchor">#</a> 14 节流</h3> <div class="language- extra-class"><pre class="language-text"><code>const throttle = function (fn, time) {
  let last = 0;
  const now = new Date().getTime();
  if (now - last &gt; time) {
    fn();
    last = now;
  }
};
</code></pre></div><h2 id="进阶算法题"><a href="#进阶算法题" aria-hidden="true" class="header-anchor">#</a> 进阶算法题</h2> <h3 id="_15-js实现链表"><a href="#_15-js实现链表" aria-hidden="true" class="header-anchor">#</a> 15 js实现链表</h3> <p>链表其实有许多的种类：单向链表、双向链表、单向循环链表和双向循环链表，接下来，我们基于对象来实现一个单向链表，因为它的使用最为广泛。</p> <div class="language- extra-class"><pre class="language-text"><code> //节点
 
function Node(element) {
    this.element = element;   //当前节点的元素
    this.next = null;         //下一个节点链接
    this.previous = null;         //上一个节点链接
}

//链表类

function LList () {
    this.head = new Node( 'head' );
    this.find = find;
    this.findLast = findLast;
    this.insert = insert;
    this.remove = remove;
    this.display = display;
    this.dispReverse = dispReverse;
}

//查找元素

function find ( item ) {
    var currNode = this.head;
    while ( currNode.element != item ){
        currNode = currNode.next;
    }
    return currNode;
}

//查找链表中的最后一个元素

function findLast () {
    var currNode = this.head;
    while ( !( currNode.next == null )){
        currNode = currNode.next;
    }
    return currNode;
}


//插入节点

function insert ( newElement , item ) {
    var newNode = new Node( newElement );
    var currNode = this.find( item );
    newNode.next = currNode.next;
    newNode.previous = currNode;
    currNode.next = newNode;
}

//显示链表元素

function display () {
    var currNode = this.head;
    while ( !(currNode.next == null) ){
        console.debug( currNode.next.element );
        currNode = currNode.next;
    }
}

//反向显示链表元素

function dispReverse () {
    var currNode = this.findLast();
    while ( !( currNode.previous == null )){
        console.log( currNode.element );
        currNode = currNode.previous;
    }
}

//删除节点

function remove ( item ) {
    var currNode = this.find ( item );
    if( !( currNode.next == null ) ){
        currNode.previous.next = currNode.next;
        currNode.next.previous = currNode.previous;
        currNode.next = null;
        currNode.previous = null;
    }
}

var fruits = new LList();

fruits.insert('Apple' , 'head');
fruits.insert('Banana' , 'Apple');
fruits.insert('Pear' , 'Banana');
fruits.insert('Grape' , 'Pear');

console.log( fruits.display() );        // Apple
                                        // Banana
                                        // Pear
                                        // Grape
                                        
console.log( fruits.dispReverse() );    // Grape
                                        // Pear
                                        // Banana
                                        // Apple
</code></pre></div><h3 id="_16-前端框架的diff算法"><a href="#_16-前端框架的diff算法" aria-hidden="true" class="header-anchor">#</a> 16 前端框架的diff算法</h3> <p>vue2.0加入了virtual dom，有点向react靠拢的意思。vue的diff位于patch.js文件中，复杂度为O(n)。
听大神说了解diff过程可以让我们更高效的使用框架，工作和女朋友都更加好找了，我们赶快了解哈~。
了解diff过程，我们先从虚拟dom开始。</p> <p>所谓的virtual dom，也就是虚拟节点。它通过JS的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点
dom diff 则是通过JS层面的计算，返回一个patch对象，即补丁对象，在通过特定的操作解析patch对象，完成页面的重新渲染，</p> <p>实现步骤
用JavaScript对象模拟DOM
把此虚拟DOM转成真实DOM并插入页面中
如果有事件发生修改了虚拟DOM
比较两棵虚拟DOM树的差异，得到差异对象
把差异对象应用到真正的DOM树上</p> <div class="language- extra-class"><pre class="language-text"><code>class crtateElement {
    constructor (el, attr, child) {
        this.el = el
        this.attrs = attr
        this.child = child || []
    }
    render () { 
        let virtualDOM =  document.createElement(this.el)
        // attr是个对象所以要遍历渲染
        for (var attr in this.attrs) {
            virtualDOM.setAttribute(attr, this.attrs[attr])
        }

        // 深度遍历child
        this.child.forEach(el =&gt; {
            console.log(el instanceof crtateElement)
            //如果子节点是一个元素的话，就调用它的render方法创建子节点的真实DOM，如果是一个字符串的话，创建一个文件节点就可以了
            // 判断一个对象是否是某个对象的实力
            let childElement = (el instanceof crtateElement) ? el.render() : document.createTextNode(el);
            virtualDOM.appendChild(childElement);
        });
        return virtualDOM
    }
}
function element (el, attr, child) {
    return new crtateElement(el, attr, child)
}

module.exports = element
</code></pre></div><p>用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中</p> <div class="language- extra-class"><pre class="language-text"><code>let element = require('./element') 

let myobj = {
    &quot;class&quot;: 'big_div'
}
let ul = element('div',myobj,[
    '我是文字',
    element('div',{'id': 'xiao'},['1']),
    element('div',{'id': 'xiao1'},['2']),
    element('div',{'id': 'xiao2'},['3']),
])
console.log(ul)
ul = ul.render()
document.body.appendChild(ul)
</code></pre></div><p>比较两棵DOM树的差异是Virtual DOM算法最核心的部分.简单的说就是新旧虚拟dom 的比较，如果有差异就以新的为准，然后再插入的真实的dom中，重新渲染。</p> <p>比较只会在同层级进行, 不会跨层级比较。
比较后会出现四种情况：
1、此节点是否被移除 -&gt; 添加新的节点
2、属性是否被改变 -&gt; 旧属性改为新属性
3、文本内容被改变-&gt; 旧内容改为新内容
4、节点要被整个替换  -&gt; 结构完全不相同 移除整个替换
看diff.js 的简单代码实现，下面都有相应的解释说明</p> <div class="language- extra-class"><pre class="language-text"><code>let utils = require('./utils');

let keyIndex = 0;
function diff(oldTree, newTree) {
    //记录差异的空对象。key就是老节点在原来虚拟DOM树中的序号，值就是一个差异对象数组
    let patches = {};
    keyIndex = 0;  // 儿子要起另外一个标识
    let index = 0; // 父亲的表示 1 儿子的标识就是1.1 1.2
    walk(oldTree, newTree, index, patches);
    return patches;
}
//遍历
function walk(oldNode, newNode, index, patches) {
    let currentPatches = [];//这个数组里记录了所有的oldNode的变化
    if (!newNode) {//如果新节点没有了，则认为此节点被删除了
        currentPatches.push({ type: utils.REMOVE, index });
        //如果说老节点的新的节点都是文本节点的话
    } else if (utils.isString(oldNode) &amp;&amp; utils.isString(newNode)) {
        //如果新的字符符值和旧的不一样
        if (oldNode != newNode) {
            ///文本改变 
            currentPatches.push({ type: utils.TEXT, content: newNode });
        }
    } else if (oldNode.tagName == newNode.tagName) {
        //比较新旧元素的属性对象
        let attrsPatch = diffAttr(oldNode.attrs, newNode.attrs);
        //如果新旧元素有差异 的属性的话
        if (Object.keys(attrsPatch).length &gt; 0) {
            //添加到差异数组中去
            currentPatches.push({ type: utils.ATTRS, attrs: attrsPatch });
        }
        //自己比完后再比自己的儿子们
        diffChildren(oldNode.children, newNode.children, index, patches, currentPatches);
    } else {
        currentPatches.push({ type: utils.REPLACE, node: newNode });
    }
    if (currentPatches.length &gt; 0) {
      patches[index] = currentPatches;
    }
}
//老的节点的儿子们 新节点的儿子们 父节点的序号 完整补丁对象 当前旧节点的补丁对象
function diffChildren(oldChildren, newChildren, index, patches, currentPatches) {
    oldChildren.forEach((child, idx) =&gt; {
        walk(child, newChildren[idx], ++keyIndex, patches);
    });
}
function diffAttr(oldAttrs, newAttrs) {
    let attrsPatch = {};
    for (let attr in oldAttrs) {
        //如果说老的属性和新属性不一样。一种是值改变 ，一种是属性被删除 了
        if (oldAttrs[attr] != newAttrs[attr]) {
            attrsPatch[attr] = newAttrs[attr];
        }
    }
    for (let attr in newAttrs) {
        if (!oldAttrs.hasOwnProperty(attr)) {
            attrsPatch[attr] = newAttrs[attr];
        }
    }
    return attrsPatch;
}
module.exports = diff;
</code></pre></div><p>其中有个需要注意的是新旧虚拟dom比较的时候，是先同层比较，同层比较完看看时候有儿子，有则需要继续比较下去，直到没有儿子。</p> <div class="language- extra-class"><pre class="language-text"><code>let keyIndex = 0;
let utils = require('./utils');
let allPatches;//这里就是完整的补丁包
function patch(root, patches) {
    allPatches = patches;
    walk(root);
}
function walk(node) {
    let currentPatches = allPatches[keyIndex++];
    (node.childNodes || []).forEach(child =&gt; walk(child));
    if (currentPatches) {
        doPatch(node, currentPatches);
    }
}
function doPatch(node, currentPatches) {
    currentPatches.forEach(patch =&gt; {
        switch (patch.type) {
            case utils.ATTRS:
                for (let attr in patch.attrs) {
                    let value = patch.attrs[attr];
                    if (value) {
                        utils.setAttr(node, attr, value);
                    } else {
                        node.removeAttribute(attr);
                    }
                }
                break;
            case utils.TEXT:
                node.textContent = patch.content;
                break;
            case utils.REPLACE:
                let newNode = (patch.node instanceof Element) ? path.node.render() : document.createTextNode(path.node);
                node.parentNode.replaceChild(newNode, node);
                break;
            case utils.REMOVE:
                node.parentNode.removeChild(node);
                break;
        }
    });
}
module.exports = patch;
</code></pre></div><h3 id="_17-js实现二叉树"><a href="#_17-js实现二叉树" aria-hidden="true" class="header-anchor">#</a> 17 js实现二叉树</h3> <div class="language- extra-class"><pre class="language-text"><code>//定义节点
class Node {
    constructor(data){
        this.root = this;
        this.data = data;
        this.left = null;
        this.right = null
    }
}
//创建二叉搜索树(BST)）
class BinarySearchTree {
    constructor(){
    this.root = null
    }
    //插入节点
    insert(data){
        const newNode = new Node(data);
        const insertNode = (node,newNode) =&gt; {
            if (newNode.data &lt; node.data){
                if(node.left === null){
                    node.left = newNode
                }else {
                    insertNode(node.left,newNode)
                }
            }else {
                if(node.right === null){
                    node.right = newNode
                }else{
                    insertNode(node.right,newNode)
                }

            }
        };
        if(!this.root){
            this.root = newNode
        }else {
            insertNode(this.root,newNode)

        }
    }
    //中序遍历
    inOrder(){
        let backs = [];
        const inOrderNode = (node,callback) =&gt; {
            if(node !== null){
                inOrderNode(node.left,callback);
                backs.push(callback(node.data));
                inOrderNode(node.right,callback)
            }
        };
        inOrderNode(this.root,callback);
        function callback(v){
            return v
        }
        return backs
    }
    //前序遍历
    preOrder(){
        let backs = [];
        const preOrderNode = (node,callback) =&gt; {
            if(node !== null){
                backs.push(callback(node.data));
                preOrderNode(node.left,callback);
                preOrderNode(node.right,callback)
            }
        };
        preOrderNode(this.root,callback);
        function callback(v){
            return v
        }
        return backs
    }
    //后序遍历
    postOrder(){
        let backs = [];
        const postOrderNode = (node,callback) =&gt; {
            if(node !== null){
                postOrderNode(node.left,callback);
                postOrderNode(node.right,callback);
                backs.push(callback(node.data))
            }
        };
        postOrderNode(this.root,callback);
        function callback(v){
            return v
        }
        return backs
    }
    //查找最小值
    getMin(node){
        const minNode = node =&gt; {
            return node? (node.left? minNode(node.left):node):null
        };
        return minNode( node || this.root)
    }
    //查找最大值
    getMax(node){
        const minNode = node =&gt; {
            return node? (node.right? minNode(node.right):node):null
        };
        return minNode(node || this.root)
    }
    //查找特定值
    find(data){
        const findNode = (node,data) =&gt; {
            if(node===null) return false;
            if(node.data===data) return node;
            return findNode((data &lt; node.data)? node.left: node.right,data)
        };
        return findNode(this.root,data)

    }
    //删除节点
    remove(data){
        const removeNode = (node,data) =&gt; {
            if(node === null) return null;
            if(node.data === data){
                if(node.left === null &amp;&amp; node.right === null) return null;
                if(node.left === null) return node.right;
                if(node.right === null) return node.left;
                if(node.left !==null &amp;&amp; node.right !==null){
                let _node = this.getMin(node.right);
                node.data = _node.data;
                node.right = removeNode(node.right,data);
                return node
                }
            } else if(data &lt; node.data){
                node.left=removeNode(node.left,data);
                return node
            } else {
                node.right=removeNode(node.right,data);
                return node
            }
        };
        return removeNode(this.root,data)
    }
}
</code></pre></div><h3 id="_18-下面这段程序的结果是？"><a href="#_18-下面这段程序的结果是？" aria-hidden="true" class="header-anchor">#</a> 18 下面这段程序的结果是？</h3> <div class="language- extra-class"><pre class="language-text"><code>for (var i = 0; i &lt; 5; i++) {
 setTimeout(function() {
  console.log(i);
 }, 1000);
}
 
console.log(i);
</code></pre></div><ul><li><p>只要你对 JS 中同步和异步代码的区别、变量作用域、闭包等概念有正确的理解，就知道正确答案是5,5,5,5,5,5；</p></li> <li><p>若用-&gt;表示其前后的两次输出之间有 1 秒，而逗号表示间隔可以忽略，结果是？ 循环执行过程中，几乎同时设置了 5 个定时器，一般情况下，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的, 所以结果是 5 -&gt; 5,5,5,5,5；</p></li> <li><p>如果期望代码的输出变成：5 -&gt; 0,1,2,3,4，该怎么改造代码？ 巧妙的利用 IIFE（声明即执行的函数表达式）来解决闭包造成的问题, 相当于把i赋值给了j这个局部变量:</p> <div class="language- extra-class"><pre class="language-text"><code>for (var i = 0; i &lt; 5; i++) {
(function(j) { 
  setTimeout(function() {
  console.log(j);
  }, 1000);
})(i);
}
console.log(i);
</code></pre></div></li> <li><p>有没有更符合直觉的做法？ 利用 JS 中基本类型的参数传递是按值传递的特征, 对循环体稍做手脚，让负责输出的那段代码能拿到每次循环的 i 值即可:</p> <div class="language- extra-class"><pre class="language-text"><code>var print = function (i) {
setTimeout(function() {
  console.log(i);
}, 1000);
};
for (var i = 0; i &lt; 5; i++) {
  print(i); // 传递到 print 的 i 值被复制了
}
console.log(i);
</code></pre></div></li> <li><p>如果期望代码的输出变成 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？</p> <div class="language- extra-class"><pre class="language-text"><code>for (var i = 0; i &lt; 5; i++) {
  (function(j) {
    setTimeout(function() {
    console.log(j);
    }, 1000 * j)); // 这里修改 0~4 的定时器时间
  })(i);
}

setTimeout(function() { // 这里增加定时器，超时设置为 5 秒
  console.log(i);
}, 1000 * i);
</code></pre></div></li> <li><p>有没有基于ES6 Promise 的解决方案 ?</p> <div class="language- extra-class"><pre class="language-text"><code>const tasks = [];
for (var i = 0; i &lt; 5; i++) { 
  ((j) =&gt; {
    tasks.push(new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      console.log(j);
      resolve(); // 一定要 resolve
    }, 1000 * j); 
    }));
  })(i);
}

Promise.all(tasks).then(() =&gt; {
  setTimeout(() =&gt; {
    console.log( i);
  }, 1000); // 只需把超时设置为 1 秒
});
</code></pre></div></li> <li><p>把上面 i 的声明改成 let，怎么做？</p> <div class="language- extra-class"><pre class="language-text"><code>const tasks = [];
for (let i = 0; i &lt; 5; i++) { 
  tasks.push(new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      console.log(j);
      resolve(); // 一定要 resolve
    }, 1000 * j); 
  }));
}

Promise.all(tasks).then(() =&gt; {
  setTimeout(() =&gt; {
    console.log( i);
  }, 1000); // 只需把超时设置为 1 秒
});
</code></pre></div></li> <li><p>有没有代码层次更好的做法？</p> <div class="language- extra-class"><pre class="language-text"><code>const tasks = []; // 存放异步操作的 Promise
const print = (i) =&gt; new Promise((resolve) =&gt; {
  setTimeout(() =&gt; {
    console.log(i);
    resolve();
  }, 1000 * i);
});

// 获得全部的异步操作
for (var i = 0; i &lt; 5; i++) {
  tasks.push(print(i));
}

// 输出最后的 i
Promise.all(tasks).then(() =&gt; {
  setTimeout(() =&gt; {
    console.log(i);
  }, 1000);
});
</code></pre></div></li> <li><p>如何使用 ES7 中的 async await 特性来让这段代码变的更简洁？</p> <div class="language- extra-class"><pre class="language-text"><code>  const sleep = (t) =&gt; new Promise((resolve) =&gt; {
    setTimeout(resolve, t);
  });
  
  (async () =&gt; { 
    for (var i = 0; i &lt; 5; i++) {
      await sleep(1000);
      console.log(i);
    }
    await sleep(1000);
    console.log(i);
  })();
</code></pre></div></li> <li><p>还能优化吗？</p> <div class="language- extra-class"><pre class="language-text"><code>  const sleep = (t) =&gt; new Promise((resolve) =&gt; {
    setTimeout(resolve, t);
  });
  
  const print = async () =&gt; { 
    for (let i = 0; i &lt;= 5; i++) {
      await sleep(1000);
      console.log(i);
    }
  };

  print();
</code></pre></div><h3 id="_19-实现发布订阅"><a href="#_19-实现发布订阅" aria-hidden="true" class="header-anchor">#</a> 19 实现发布订阅</h3> <div class="language- extra-class"><pre class="language-text"><code>class EventEmitter {
  constructor() {
      // 事件对象，存放订阅的名字和事件
      this.events = {};
  }
  // 订阅事件的方法
  on(eventName,callback) {
     if (!this.events[eventName]) {
         // 注意时数据，一个名字可以订阅多个事件函数
         this.events[eventName] = [callback]
     } else  {
        // 存在则push到指定数组的尾部保存
         this.events[eventName].push(callback)
     }
  }
  // 触发事件的方法
  emit(eventName) {
      // 遍历执行所有订阅的事件
     this.events[eventName] &amp;&amp; this.events[eventName].forEach(cb =&gt; cb());
  }
  // 移除订阅事件
  removeListener(eventName, callback) {
      if (this.events[eventName]) {
          this.events[eventName] = this.events[eventName].filter(cb =&gt; cb != callback)
      }
  }
  // 只执行一次订阅的事件，然后移除
  once(eventName,callback) {
      // 绑定的时fn, 执行的时候会触发fn函数
      let fn = () =&gt; {
         callback(); // fn函数中调用原有的callback
         this.removeListener(eventName,fn); // 删除fn, 再次执行的时候之后执行一次
      }
      this.on(eventName,fn)
  }
}
</code></pre></div></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/fe/code.html" class="prev">
          代码规范
        </a></span> <span class="next"><a href="/blog/fe/ngnix.html">
          关于ngnix
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.db404420.js" defer></script><script src="/blog/assets/js/2.07cc4d7a.js" defer></script><script src="/blog/assets/js/21.91720da3.js" defer></script>
  </body>
</html>
