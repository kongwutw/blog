<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>空无的博客</title>
    <meta name="description" content="让全栈编程更容易！">
    <link rel="icon" href="favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/blog/assets/css/0.styles.f54d1925.css" as="style"><link rel="preload" href="/blog/assets/js/app.db404420.js" as="script"><link rel="preload" href="/blog/assets/js/2.07cc4d7a.js" as="script"><link rel="preload" href="/blog/assets/js/53.124413f8.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.067c6059.js"><link rel="prefetch" href="/blog/assets/js/11.b2e97d2d.js"><link rel="prefetch" href="/blog/assets/js/12.f3b194f5.js"><link rel="prefetch" href="/blog/assets/js/13.1d46fa14.js"><link rel="prefetch" href="/blog/assets/js/14.431e1f9e.js"><link rel="prefetch" href="/blog/assets/js/15.6aab5401.js"><link rel="prefetch" href="/blog/assets/js/16.ce4a82a0.js"><link rel="prefetch" href="/blog/assets/js/17.faa86a5d.js"><link rel="prefetch" href="/blog/assets/js/18.df937046.js"><link rel="prefetch" href="/blog/assets/js/19.7cc79e8b.js"><link rel="prefetch" href="/blog/assets/js/20.88c1806d.js"><link rel="prefetch" href="/blog/assets/js/21.91720da3.js"><link rel="prefetch" href="/blog/assets/js/22.a45ca4e3.js"><link rel="prefetch" href="/blog/assets/js/23.0d1a9424.js"><link rel="prefetch" href="/blog/assets/js/24.f8dc3a1b.js"><link rel="prefetch" href="/blog/assets/js/25.1f6e2fdd.js"><link rel="prefetch" href="/blog/assets/js/26.c3faecd2.js"><link rel="prefetch" href="/blog/assets/js/27.139f423e.js"><link rel="prefetch" href="/blog/assets/js/28.c62a300b.js"><link rel="prefetch" href="/blog/assets/js/29.6d695ea3.js"><link rel="prefetch" href="/blog/assets/js/3.bc263a31.js"><link rel="prefetch" href="/blog/assets/js/30.71890272.js"><link rel="prefetch" href="/blog/assets/js/31.094dc6f8.js"><link rel="prefetch" href="/blog/assets/js/32.28fc139e.js"><link rel="prefetch" href="/blog/assets/js/33.0b875c4b.js"><link rel="prefetch" href="/blog/assets/js/34.966568f6.js"><link rel="prefetch" href="/blog/assets/js/35.879e924b.js"><link rel="prefetch" href="/blog/assets/js/36.e779ed30.js"><link rel="prefetch" href="/blog/assets/js/37.552d42b9.js"><link rel="prefetch" href="/blog/assets/js/38.e752d7eb.js"><link rel="prefetch" href="/blog/assets/js/39.5cfb1c3e.js"><link rel="prefetch" href="/blog/assets/js/4.e2e0255b.js"><link rel="prefetch" href="/blog/assets/js/40.3132f99e.js"><link rel="prefetch" href="/blog/assets/js/41.afd3b019.js"><link rel="prefetch" href="/blog/assets/js/42.b597878a.js"><link rel="prefetch" href="/blog/assets/js/43.422ac91e.js"><link rel="prefetch" href="/blog/assets/js/44.f0595a0f.js"><link rel="prefetch" href="/blog/assets/js/45.1c9c4e5c.js"><link rel="prefetch" href="/blog/assets/js/46.f61c2a6e.js"><link rel="prefetch" href="/blog/assets/js/47.85a2b141.js"><link rel="prefetch" href="/blog/assets/js/48.87d6c131.js"><link rel="prefetch" href="/blog/assets/js/49.06f36298.js"><link rel="prefetch" href="/blog/assets/js/5.c11c6e26.js"><link rel="prefetch" href="/blog/assets/js/50.bdb65770.js"><link rel="prefetch" href="/blog/assets/js/51.e5f04ec9.js"><link rel="prefetch" href="/blog/assets/js/52.abd02c2a.js"><link rel="prefetch" href="/blog/assets/js/54.17d2c69d.js"><link rel="prefetch" href="/blog/assets/js/55.926c3143.js"><link rel="prefetch" href="/blog/assets/js/56.9056faa3.js"><link rel="prefetch" href="/blog/assets/js/57.b580554f.js"><link rel="prefetch" href="/blog/assets/js/58.0fe6c4ff.js"><link rel="prefetch" href="/blog/assets/js/59.c9dedcef.js"><link rel="prefetch" href="/blog/assets/js/6.9e5d8c9e.js"><link rel="prefetch" href="/blog/assets/js/60.7994e946.js"><link rel="prefetch" href="/blog/assets/js/61.40306ba8.js"><link rel="prefetch" href="/blog/assets/js/62.10095560.js"><link rel="prefetch" href="/blog/assets/js/63.98a563bd.js"><link rel="prefetch" href="/blog/assets/js/64.3acac147.js"><link rel="prefetch" href="/blog/assets/js/65.ff6461d6.js"><link rel="prefetch" href="/blog/assets/js/66.3dd6d939.js"><link rel="prefetch" href="/blog/assets/js/67.abe72b05.js"><link rel="prefetch" href="/blog/assets/js/68.901eb929.js"><link rel="prefetch" href="/blog/assets/js/69.555bc92e.js"><link rel="prefetch" href="/blog/assets/js/7.9b93c563.js"><link rel="prefetch" href="/blog/assets/js/70.910023e2.js"><link rel="prefetch" href="/blog/assets/js/71.4e31a5f3.js"><link rel="prefetch" href="/blog/assets/js/72.f04865d2.js"><link rel="prefetch" href="/blog/assets/js/73.d9e0aa1c.js"><link rel="prefetch" href="/blog/assets/js/74.30b717b4.js"><link rel="prefetch" href="/blog/assets/js/75.7a35c8e2.js"><link rel="prefetch" href="/blog/assets/js/76.42220da8.js"><link rel="prefetch" href="/blog/assets/js/8.ab3cc639.js"><link rel="prefetch" href="/blog/assets/js/9.a9f74242.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.f54d1925.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">空无的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/jsGuide/1.html" class="nav-link">JS入门导读</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">JS高级导读</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">全栈入门</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">开发环境配置参考</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link router-link-exact-active router-link-active">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">koa+vue全栈开发实战</a></li></ul></div></div><div class="nav-item"><a href="/blog/interview/1.html" class="nav-link">面试宝典</a></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/kongwutw/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/jsGuide/1.html" class="nav-link">JS入门导读</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">JS高级导读</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">全栈入门</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">开发环境配置参考</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link router-link-exact-active router-link-active">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">koa+vue全栈开发实战</a></li></ul></div></div><div class="nav-item"><a href="/blog/interview/1.html" class="nav-link">面试宝典</a></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/kongwutw/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/share/mp.html#配置项app-json和page-json" class="sidebar-link">配置项app.json和page.json</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/share/mp.html#app-json" class="sidebar-link">app.json</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#page-json" class="sidebar-link">page.json</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#sitemap-json文件（用于微信索引）" class="sidebar-link">sitemap.json文件（用于微信索引）</a></li></ul></li><li><a href="/blog/share/mp.html#语法区别" class="sidebar-link">语法区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/share/mp.html#wxml文件跟html的区别：" class="sidebar-link">wxml文件跟html的区别：</a></li></ul></li><li><a href="/blog/share/mp.html#组件" class="sidebar-link">组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/share/mp.html#基础组件" class="sidebar-link">基础组件</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#原生组件的使用限制" class="sidebar-link">原生组件的使用限制</a></li></ul></li><li><a href="/blog/share/mp.html#事件系统" class="sidebar-link">事件系统</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/share/mp.html#小程序相关机制" class="sidebar-link">小程序相关机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/share/mp.html#小程序的运行机制：冷启动和热启动" class="sidebar-link">小程序的运行机制：冷启动和热启动</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#启动场景" class="sidebar-link">启动场景</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#更新机制" class="sidebar-link">更新机制</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#es6的支持情况：" class="sidebar-link">ES6的支持情况：</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#注册小程序" class="sidebar-link">注册小程序</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#注册页面和自定义组件" class="sidebar-link">注册页面和自定义组件</a></li></ul></li><li><a href="/blog/share/mp.html#小程序运行流程" class="sidebar-link">小程序运行流程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/share/mp.html#生命周期函数" class="sidebar-link">生命周期函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/share/mp.html#小程序生命周期函数" class="sidebar-link">小程序生命周期函数</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#页面生命周期函数" class="sidebar-link">页面生命周期函数</a></li><li class="sidebar-sub-header"><a href="/blog/share/mp.html#组件生命周期函数" class="sidebar-link">组件生命周期函数</a></li></ul></li><li><a href="/blog/share/mp.html#网络" class="sidebar-link">网络</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/share/mp.html#自定义tabbar" class="sidebar-link">自定义tabBar</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/share/mp.html#小程序登录流程" class="sidebar-link">小程序登录流程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/share/mp.html#小程序优化操作" class="sidebar-link">小程序优化操作</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>最近几个月因为公司的业务需求，一直在折腾小程序，从开始的完全不熟悉，到后面被各种坑折磨，是时候写一篇总结了，避免下一次遇到还找不到解决的方案。</p> <p>其实主要还是关于一些常用的东西进行了一次汇总，作了一个简单的总结而已，大多都跟业务相关，需要注意到的一些关注点。入门教程还是推荐直接参考微信开发的官方文档。</p> <p>本篇文档仅针对于原生官方API进行微信小程序开发，类似uni-app这类框架的总结后期再继续分享。</p> <p>目录：</p> <ul><li><a href="#%E9%85%8D%E7%BD%AE%E9%A1%B9app-json%E5%92%8Cpage-json">配置项</a></li> <li><a href="#%E8%AF%AD%E6%B3%95%E5%8C%BA%E5%88%AB">语法区别</a></li> <li><a href="#%E7%BB%84%E4%BB%B6">组件</a></li> <li><a href="#%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F">事件系统</a></li> <li><a href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6">小程序相关机制</a></li> <li><a href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B">小程序运行流程</a></li> <li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0">生命周期函数</a></li> <li><a href="#%E7%BD%91%E7%BB%9C">网络</a></li> <li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89tabbar">自定义tabBar</a></li> <li><a href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B">小程序登录流程</a></li> <li><a href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%93%8D%E4%BD%9C">小程序优化操作</a></li></ul> <h2 id="配置项app-json和page-json"><a href="#配置项app-json和page-json" aria-hidden="true" class="header-anchor">#</a> 配置项app.json和page.json</h2> <h3 id="app-json"><a href="#app-json" aria-hidden="true" class="header-anchor">#</a> app.json</h3> <p>首先，需要确定的是，app.json 是小程序的全局配置，放在根目录下。</p> <p>常用的一些字段如下：</p> <ul><li>pages： 这个用于设置页面的路径，通常访问的页面都放在pages文件夹里面，且必须在这个全局配置文件中设置好路径，否则访问的时候会报错找不到该路径，<strong>写在 pages 字段的第一个页面就是这个小程序的首页</strong>（打开小程序看到的第一个页面）</li> <li>window: 全局样式的配置
<ul><li>导航栏相关：可配置导航栏背景颜色、标题颜色，标题内容，</li> <li>可以隐藏导航栏（navigationStyle设置为custom，但需要注意，<strong>自定义导航栏仍然保留右上角胶囊，且没有返回键，如果想要实现返回功能，需要自己自定义返回的样式和功能</strong>），==该设置对web-view 组件无效==</li> <li>窗口的背景色， backgroundColor，（即小程序下拉时露出的那一截），另外，仅ios支持的还有backgroundColorTop和backgroundColorBottom， 顶部和底部窗口的背景色</li> <li>下拉loading的样式，只有黑色和白色（dark / light）</li> <li><strong>enablePullDownRefresh</strong>，小程序默认页面是没有下拉刷新功能的，如果在app.json中配置该项为true，则所有页面都可以生效。如果只想在单个页面使用下拉刷新，需要在对应的page.json中进行配置</li> <li>onReachBottomDistance， 上拉加载更多生效时距页面底部距离，默认为50px</li> <li>屏幕旋转，pageOrientation， 暂时还没有用到过，支持 auto / portrait / landscape，默认为portrait竖屏显示，</li></ul></li> <li>tabbar： tab栏设置
<ul><li>位置：支持顶部和底部（通常使用底部tab栏）， position（bottom / top）</li> <li>tab列表 list： 文字以及对应的路径
<ul><li>最少2个，最多5个</li> <li>pagePath，页面路径（必须是pages中定义的路径）</li> <li>text， tab上的文字</li> <li>iconPath， 图片路径，（<strong>大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片</strong>）</li> <li>selectedIconPath，选中时的图片路径。限制同上</li></ul></li> <li>样式相关：color字体颜色，selectedColor选中文字的颜色，backgroundColor是tab栏背景色 ，borderStyle上边框颜色，</li> <li>custom是否自定义，默认为否， 具体文档参考： <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html" target="_blank" rel="noopener noreferrer">自定义tabBar<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li> <li>networkTimeout（设置网络请求的超时时间）
<ul><li>request</li> <li>connectSocket</li> <li>uploadFile</li> <li>downloadFile</li></ul></li> <li>debug， 开启调试,会输出Page 的注册，页面路由，数据更新，事件触发等信息，方便查看生命周期的调试</li> <li>navigateToMiniProgramAppIdList， 跳转到其他小程序时，需要先在app.json中进行声明</li> <li>usingComponents，如果在app.json中声明该组件，则全局可以使用该自定义组件，不需要再在page的json中声明</li> <li>permission， 用于授权相关，平时项目中是自己写的页面，调用button的open-type属性唤起授权，其实可以通过插件功能页来实现，比如授权昵称，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/user-info.html" target="_blank" rel="noopener noreferrer">用户信息功能页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="page-json"><a href="#page-json" aria-hidden="true" class="header-anchor">#</a> page.json</h3> <p>页面的样式配置优先级比全局配置中的window高。</p> <ul><li>可以设置导航栏背景颜色、导航栏标题颜色，导航栏标题，</li> <li>可以隐藏导航栏，custom 自定义导航栏，只保留右上角胶囊按钮</li> <li>窗口的背景色	， 以及ios支持顶部和底部窗口的背景色</li> <li>backgroundTextStyle，下拉 loading 的样式，仅支持 dark / light</li> <li>enablePullDownRefresh开启下拉刷新，这个属性只控制当前的page页面可以刷新</li> <li>onReachBottomDistance，上拉加载更多生效时距页面底部距离，默认为50px</li> <li>pageOrientation，屏幕旋转设置</li> <li><strong>disableScroll</strong>，为 true 则页面整体不能上下滚动。只在页面配置中有效，无法在 app.json 中设置</li> <li>disableSwipeBack， 禁止页面右滑手势返回</li> <li>usingComponents， 使用自定义组件，如果没有在页面的json中声明，直接使用组件会报错</li></ul> <h3 id="sitemap-json文件（用于微信索引）"><a href="#sitemap-json文件（用于微信索引）" aria-hidden="true" class="header-anchor">#</a> sitemap.json文件（用于微信索引）</h3> <p>默认规则为都默认被索引：</p> <p><code>{&quot;action&quot;: &quot;allow&quot;, &quot;page&quot;: &quot;*&quot;}</code></p> <h2 id="语法区别"><a href="#语法区别" aria-hidden="true" class="header-anchor">#</a> 语法区别</h2> <h3 id="wxml文件跟html的区别："><a href="#wxml文件跟html的区别：" aria-hidden="true" class="header-anchor">#</a> wxml文件跟html的区别：</h3> <ul><li>没有div, p, span， 使用view代替div， text代替span</li> <li>wx:if的使用同vue中的v-if， 但使用上略有区别，不管在标签中还是文本上，都是使用双大括号来表示插值， <code>wx:for=&quot;&quot;</code>,</li> <li>条件渲染有wx:if, wx:elif, wx:else, 使用方式： <code>&lt;view wx:if=&quot;false&quot;&gt; WEBVIEW &lt;/view&gt;</code></li> <li><strong>尤其注意，如果是使用boolean类型的值，不要直接在双引号内直接写，也需要写在双大括号里面。如<code>&lt;checkbox checked=&quot;false&quot;&gt; &lt;/checkbox&gt;</code></strong></li> <li>列表渲染<code>wx:for=&quot;&quot;</code>, 可直接使用item和index，也可以使用<code>wx:for-item=&quot;idx&quot;</code>, 和<code>wx:for-item=&quot;itemName&quot;</code>重新指定index和item的key值，<strong>花括号和引号之间如果有空格，将最终被解析成为字符串</strong></li> <li>wxml文件中有一个标签是block， 仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性</li> <li>wx:key的值只能是字符串或者 &quot;*this&quot;, <code>wx:key=&quot;*this&quot;</code>表示for 循环中的 item 本身， 但是要保证这个item本身是一个唯一的字符串或者数字， 当key绑定的是对象的时候会报错</li></ul> <p>问题思考？</p> <p><code>wx:if</code> 和 <code>hidden</code>该怎么合理的判断使用场景？</p> <ul><li>wx:if 是惰性的，只有为true时才会局部渲染，当 wx:if 的条件值切换时，条件块会在切换时销毁或重新渲染。</li> <li>而hidden始终会被渲染，只是控制显示与隐藏</li> <li>所以，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好</li></ul> <h2 id="组件"><a href="#组件" aria-hidden="true" class="header-anchor">#</a> 组件</h2> <h3 id="基础组件"><a href="#基础组件" aria-hidden="true" class="header-anchor">#</a> 基础组件</h3> <ul><li>组件的公共属性：
<ul><li>id, class, style, hidden, data-<em>, bind</em>/catch*</li></ul></li> <li>视图容器：
<ul><li>可移动： movable-area， movable-view。 其中，movable-view必须在 movable-area 组件中，并且必须是直接子节点</li> <li>覆盖原生组件：cover-view， cover-image，主要用于覆盖 map、video、canvas、camera、live-player、live-pusher等级别高的原生组件。 <strong>注意，在cover-view中只能嵌套cover-view、cover-image和button</strong></li> <li>可滚动的视图区域：scroll-view，<strong>竖向滚动时，需要给scroll-view一个固定高度</strong></li> <li>滑块视图容器： swiper， 其中只能放置swiper-item组件（常用于轮播图）</li> <li>视图容器view， 如果想使用hover的样式，可以指定按下去的样式类，跟hover相关的属性： hover-class，hover-stop-propagation， hover-start-time， hover-stay-time</li></ul></li> <li>图标icon，在小程序中可以使用自带的一些icon图标，可以设置type、大小、颜色，详情查看， <a href="https://developers.weixin.qq.com/miniprogram/dev/component/icon.html" target="_blank" rel="noopener noreferrer">小程序icon组件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>进度条，progress， 普通的进度条包括动画等可以直接使用该组件</li> <li>富文本，rich-txt, (可以使用该组件渲染html内容，传入html字符串)</li> <li>文本，text， （如果需要展示多个空格，可以设置space属性）</li> <li>按钮，button，（可以设置disabled属性进行禁用，防止多次点击触发事件）</li> <li>单选、多选框：radio、radio-goup、checkbox、checkbox-group</li> <li>富文本编辑器，editor</li> <li>表单form，支持switch input checkbox slider radio picker 的提交</li> <li>输入框input，支持文本、数字、身份证、带小数点的数字键盘等4个类型，password可以显示密码类型，（可以控制键盘右下角的文字，使用confirm-type属性控制，包括“发送”、“搜索”、“下一个”、“前往”、“完成”）注意：input无法设置 font-family，使用的是系统字体</li> <li>滚动选择器，picker，支持普通、多列、时间、日期、省市选择器，</li> <li>嵌入页面的滚动选择器， picker-view， picker-view-column</li> <li>滑动选择器，slider，类似进度条不过可以拖动</li> <li>开关，switch</li> <li>多行输入框，textarea</li> <li>导航，navigator，（类似于a标签，可以使用navigate、redirect、switchTab、reLaunch、navigateBack、exit（退出小程序）等类型）</li> <li>系统相机，camera，可以用于扫描二维码</li> <li>视频video，（注意，使用video组件在列表中的时候会引起小程序页面卡顿甚至崩溃，目前项目中的解决方案是使用阿里云上传视频的截帧图片来替换掉video组件，只有点击图片后才会播放视频，查看网上资料说是video的src默认为空，解决了viode自动下载的bug，使用custom-cache=&quot;false&quot;可以解决视频缓存中卡住的问题，不过还没有试过）</li> <li>公众号关注组件，official-account</li> <li>承载网页的容器，web-view，（适用于第三方网站内容的嵌入，注意需要在公众平台配置业务域名），避免在链接中带有中文字符，在 iOS中会有打开白屏的问题，建议加一下encodeURIComponent</li></ul> <h3 id="原生组件的使用限制"><a href="#原生组件的使用限制" aria-hidden="true" class="header-anchor">#</a> 原生组件的使用限制</h3> <ul><li>原生组件包括：
<ul><li>camera</li> <li>canvas</li> <li>input（仅在focus时表现为原生组件）</li> <li>live-player</li> <li>live-pusher</li> <li>map</li> <li>textarea</li> <li>video</li></ul></li> <li>层级： 最高，其他组件无论设置 z-index 为多少，都无法盖在原生组件上</li> <li>原生组件不能设置动画、fixed布局、不能使用overflow: hidden来裁剪原生组件的显示区域，</li> <li>事件监听不能使用 bind:eventname 的写法，只支持 bindeventname，不支持 catch 和 capture 的事件绑定方式</li></ul> <h2 id="事件系统"><a href="#事件系统" aria-hidden="true" class="header-anchor">#</a> 事件系统</h2> <ul><li><p>事件处理函数，参数是event，event的事件内容包括：</p> <ul><li>type</li> <li>timeStamp， 事件生成时的时间戳</li> <li>target，触发事件的<strong>源组件</strong></li> <li>currentTarget，事件绑定的<strong>当前组件</strong></li> <li>detail， 自定义事件所携带的数据</li> <li>touches，一个数组，每个元素为一个 Touch 对象</li> <li>changedTouches， 有变化的触摸点</li></ul></li> <li><p>dataset：在target或currentTarget的事件对象中，可以通过dataset获取当前自定义的一些数据，（在JS文件中使用event.currentTarget.dataset时，dataset的属性会自动转换字符串，<strong>连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符</strong>）</p></li> <li><p>mark，类似于dataset，（如果存在同名的 mark ，父节点的 mark 会被子节点覆盖）</p></li> <li><p>页面的用户行为：</p> <ul><li>下拉刷新 onPullDownRefresh</li> <li>上拉触底 onReachBottom</li> <li>页面滚动 onPageScroll</li> <li>用户转发 onShareAppMessage</li></ul></li></ul> <p>思考：</p> <ol><li>小程序中bind事件和catch事件有什么区别？</li></ol> <ul><li>bind事件绑定不会阻止冒泡事件向上冒泡，</li> <li>catch事件绑定可以阻止冒泡事件向上冒泡</li></ul> <ol start="2"><li>target和currentTarget有什么不同？</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;view id=&quot;outer&quot; bindtap=&quot;handleTap1&quot;&gt;
  outer view
  &lt;view id=&quot;middle&quot; catchtap=&quot;handleTap2&quot;&gt;
    middle view
    &lt;view id=&quot;inner&quot; bindtap=&quot;handleTap3&quot;&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre></div><p>如上面这个示例中，点击inner view会触发handleTap3，同时会冒泡到handleTap2。
对于handleTap2这个组件来说，此时收到事件对象的target就是inner的元素，而currentTarget是middle的部分</p> <ol start="3"><li>mark 和 dataset 有什么区别？</li></ol> <ul><li>mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；</li> <li>dataset 仅包含一个节点的 data- 属性值</li> <li>节点的 mark 不会做连字符和大小写转换</li></ul> <h2 id="小程序相关机制"><a href="#小程序相关机制" aria-hidden="true" class="header-anchor">#</a> 小程序相关机制</h2> <ul><li>小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 web 中一些能力都无法使用，如 window，document 等</li></ul> <h3 id="小程序的运行机制：冷启动和热启动"><a href="#小程序的运行机制：冷启动和热启动" aria-hidden="true" class="header-anchor">#</a> 小程序的运行机制：冷启动和热启动</h3> <ul><li>冷启动： 首次打开小程序；或小程序销毁后打开。（冷启动会触发app.js中的onLaunch生命周期函数）</li> <li>热启动： 点击右上角胶囊退出、或者home键离开微信、或者左右滑动返回到微信等动作，都是热启动，并没有销毁小程序，（所以热启动不会触发onLaunch函数，但会触发onShow函数）</li></ul> <h3 id="启动场景"><a href="#启动场景" aria-hidden="true" class="header-anchor">#</a> 启动场景</h3> <ul><li>小程序启动场景分为两种：
<ul><li>从发现栏、另一个小程序返回、微信支付、首页下拉小程序栏等为A场景</li> <li>B场景：打开某个特定页面：如转发分享的卡片链接</li></ul></li> <li>热启动场景效果：
<ol><li>如果重新进入的场景和退出时的场景都是A场景，则保留原来状态；例如：停留在“个人中心”页面，退出后，下拉首页的小程序列表进入后还是会停留在“个人中心”页面，（触发“个人中心”Page的onShow函数，但是不会触发onLoad函数）</li> <li>如果当前是A场景，上一个是B场景，则清空原来的页面栈，打开首页（即执行 wx.reLaunch 到首页）如分享出去的卡片是“学员列表”页面，点击卡片停留后退出，再从首页下拉的小程序进入，此时会跳转到首页</li> <li>不管上一个场景是什么，如果当前是B场景，如点击小程序的分享卡片，此时会清空原来的页面栈，重新进入这个分享页，首先触发app中的onShow函数，然后触发这个分享页的onLoad函数，当然如果app中已经进行了跳转到其它页面，则不会再走这个分享页。</li></ol></li> <li>冷启动场景效果：
<ul><li>冷启动规则比较简单，如果冷启动时是A场景，则进入小程序首页</li> <li>如果冷启动时是B场景，则进入对应的特定页面</li></ul></li></ul> <h3 id="更新机制"><a href="#更新机制" aria-hidden="true" class="header-anchor">#</a> 更新机制</h3> <ul><li>小程序首先会在后台有一个最新版本，一般来说会在24小时内下发新版本信息到用户，静默更新到新版本（此时用户是无感知态）</li> <li>在后台还没及时更新版本时，每次冷启动都会检测是否有更新版本，如果有，会<strong>异步下载</strong>，同时启动当前的旧版本包，所以新版本需要下一次的冷启动才会应用上</li> <li>如果启动时就想立刻获取最新版本，需要使用 wx.getUpdateManager 的API，用wx.showModal提示用户是否重启应用更新</li></ul> <h3 id="es6的支持情况："><a href="#es6的支持情况：" aria-hidden="true" class="header-anchor">#</a> ES6的支持情况：</h3> <ul><li>微信小程序已经支持了绝大部分的 ES6 API，但部分API仍依赖于系统版本而不支持</li> <li>String的normalize在ios8，ios9不支持</li> <li>数组的values在ios8和android不支持</li> <li>数组的includes在ios8不支持</li> <li>Proxy不支持ios8、ios9和android</li></ul> <h3 id="注册小程序"><a href="#注册小程序" aria-hidden="true" class="header-anchor">#</a> 注册小程序</h3> <ul><li>app.js中注册小程序，整个小程序只有一个 App 实例，是全部页面共享的。</li> <li>开发者可以通过 getApp 方法获取到全局唯一的 App 示例，获取App上的数据或调用开发者注册在 App 上的函数</li> <li>在app.js中可以直接使用this.globalData赋值，但在其他页面需通过getApp()方法获取到实例后才能使用全局变量globalData</li></ul> <div class="language- extra-class"><pre class="language-text"><code>App({
  onLaunch: function(options) {},
  onShow: function(options) {},
  onHide: function() {},
  onError: function(msg) {},
  globalData: 'I am global data'
})
</code></pre></div><h3 id="注册页面和自定义组件"><a href="#注册页面和自定义组件" aria-hidden="true" class="header-anchor">#</a> 注册页面和自定义组件</h3> <h4 id="页面"><a href="#页面" aria-hidden="true" class="header-anchor">#</a> 页面</h4> <ul><li>data 是页面第一次渲染使用的初始数据</li> <li>onLoad页面加载时触发。一个页面只会调用一次；</li> <li>onShow在页面显示/切入前台时触发</li> <li>onPageScroll，监听用户滑动页面事件，（<strong>请避免在 onPageScroll 中过于频繁的执行 setData 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时</strong>）</li> <li>onShareAppMessage监听页面内的转发，转发有button 组件 open-type=&quot;share&quot;和右上角转发两个方式，（只有Page中定义了onShareAppMessage，右上角才会出现转发功能）</li> <li>setData：
<ul><li>将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）（跟react的setState类似，但又不一样）</li> <li>直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致</li> <li>不要把 data 中任何一项的 value 设为 undefined</li> <li>如果需要视图层更新完毕后再处理事件，可以将事件放在setData的回调函数中</li></ul></li></ul> <p>Page构造器：</p> <div class="language- extra-class"><pre class="language-text"><code>Page({
  data: { text: &quot;This is page data.&quot; },
  onLoad: function(options) { },
  onReady: function() { },
  onShow: function() { },
  onHide: function() { },
  onUnload: function() { },
  onPullDownRefresh: function() { },
  onReachBottom: function() { },
  onShareAppMessage: function () { },
  onPageScroll: function() { }
})
</code></pre></div><h4 id="自定义组件"><a href="#自定义组件" aria-hidden="true" class="header-anchor">#</a> 自定义组件</h4> <ul><li>页面使用自定义组件时需要现在page的json文件中声明usingComponents定义段</li> <li>组件使用页面的生命周期方法时（即 on 开头的方法），应该写在methods定义段中</li> <li><strong>behaviors</strong>提取所有页面中公用的代码段，例如，<strong>在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 behaviors 中</strong></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// page-common-behavior.js
module.exports = Behavior({
  attached: function() {
    // 页面创建时执行
    console.info('Page loaded!')
  },
  detached: function() {
    // 页面销毁时执行
    console.info('Page unloaded!')
  }
})


// 页面 A
var pageCommonBehavior = require('./page-common-behavior')
Component({
  behaviors: [pageCommonBehavior],
  data: { /* ... */ },
  methods: { /* ... */ },
})


// 页面 B
var pageCommonBehavior = require('./page-common-behavior')
Component({
  behaviors: [pageCommonBehavior],
  data: { /* ... */ },
  methods: { /* ... */ },
})
</code></pre></div><ul><li>在 properties 定义段中，属性名采用驼峰写法（propertyName）；在 wxml 中，指定属性值时则对应使用连字符写法（component-tag-name property-name=&quot;attr value&quot;），应用于数据绑定时采用驼峰写法（attr=&quot;&quot;）</li> <li>observers数据监听器，（类似于vue中的watch），具体请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html" target="_blank" rel="noopener noreferrer">数据监听器
<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>created，组件实例刚被创建，（<strong>注意此时不能调用 setData</strong>）</li> <li>definitionFilter，定义段过滤器，用于自定义组件扩展（如扩展自定义组件一个computed计算属性功能）</li></ul> <p><strong>注意：</strong></p> <ul><li>使用 this.data 可以获取内部数据和属性值；但直接修改它不会将变更应用到界面上，应使用 setData 修改</li> <li>生命周期函数无法在组件方法中通过 this 访问到</li></ul> <h5 id="组件间的通信与事件"><a href="#组件间的通信与事件" aria-hidden="true" class="header-anchor">#</a> 组件间的通信与事件</h5> <ul><li>父传子：父组件绑定属性值，子组件通过properties获取，</li> <li>子组件向父组件传递数据：使用事件传递</li> <li>父组件访问子组件： 父组件可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法</li></ul> <p>此处列举第二种自定义事件传递数据的方法：</p> <div class="language- extra-class"><pre class="language-text"><code>// 1. 父组件中监听事件
&lt;component-tag-name bindmyevent=&quot;onMyEvent&quot; /&gt;

// 2. 子组件触发事件，触发wxml的onMyEvent事件，触发父组件的方法
&lt;!--自定义组件中--&gt;
&lt;button bindtap=&quot;onTap&quot;&gt;点击这个按钮将触发“myevent”事件&lt;/button&gt;

&lt;!--自定义组件js文件中--&gt;
Component({
  properties: {},
  methods: {
    onTap: function(){
      var myEventDetail = {} // detail对象，提供给事件监听函数
      var myEventOption = {} // 触发事件的选项
      this.triggerEvent('myevent', myEventDetail, myEventOption)
    }
  }
})

</code></pre></div><p>具体可参考文档： <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html" target="_blank" rel="noopener noreferrer">组件间通信与事件
<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><strong>注意：</strong></p> <ul><li>组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器</li> <li>避免使用后代选择器（.a .b）</li> <li>子元素选择器（.a&gt;.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况</li> <li>app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除继承样式外，如 font 、 color会继承自组件外）</li></ul> <h5 id="组件间关系"><a href="#组件间关系" aria-hidden="true" class="header-anchor">#</a> 组件间关系</h5> <p>场景： 如果一个页面中需要使用到A组件和B组件，而A组件与B组件之间需要通信，此时可以在组件定义时加入relations定义段，如封装的ul和li组件后，之间需要存在关联的父子关系</p> <ul><li>必须在两个组件定义中都加入relations定义，否则不会生效</li> <li>type，与目标组件的相对关系，可选的值为 parent 、 child 、 ancestor 、 descendant</li> <li>另一种情况是关联一类组件（如form与input、checkbox等的关系），需要使用到behavior</li></ul> <p>具体使用方式参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html" target="_blank" rel="noopener noreferrer">组件间关系<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h5 id="使用setdata应注意的事项："><a href="#使用setdata应注意的事项：" aria-hidden="true" class="header-anchor">#</a> 使用setData应注意的事项：</h5> <ul><li>不要频繁的去 setData，否则可能导致Android 下用户在滑动时会感觉到卡顿，或者渲染有出现延时</li> <li>不要每次 setData 都传递大量新数据</li> <li>不要在后台态页面进行 setData ，</li></ul> <h2 id="小程序运行流程"><a href="#小程序运行流程" aria-hidden="true" class="header-anchor">#</a> 小程序运行流程</h2> <ol><li>微信打开小程序前，会把整个小程序的代码包下载到本地</li> <li>通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径</li> <li>写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面），所以微信会把首页的代码装载进来</li> <li>小程序启动，触发app.js 定义的 App 实例的 onLaunch回调，启动时也会触发onShow函数，或切前台、从其他页面返回到这个页面，都会触发onShow；onHide监听小程序切后台，（如tab切换，navigateTo，离开微信等）； onPageNotFound页面不存在监听函数</li> <li>页面的渲染流程开始，微信客户端会先根据 page的json文件配置生成一个界面，</li> <li>接着装载这个页面的 WXML 结构和 WXSS 样式</li> <li>最后客户端会装载 page的js文件</li> <li>Page构造器会生成一个页面，生成页面的时候小程序框架会把 data 数据和 index.wxml 一起渲染出最终的结构，渲染完界面</li> <li>渲染完界面之后，页面实例就会收到一个 onLoad 的回调</li></ol> <h2 id="生命周期函数"><a href="#生命周期函数" aria-hidden="true" class="header-anchor">#</a> 生命周期函数</h2> <p>小程序里面又三种生命周期：小程序运行的生命周期（在app.js中处理），页面的生命周期（在page的js文件中处理，或者组件的pageLifetimes触发的生命周期函数），组件的生命周期</p> <h3 id="小程序生命周期函数"><a href="#小程序生命周期函数" aria-hidden="true" class="header-anchor">#</a> 小程序生命周期函数</h3> <ul><li>onLaunch， 小程序初始化完成时触发，全局只触发一次</li> <li>onShow，小程序启动，或从后台进入前台显示时触发</li> <li>onHide，从前台进入后台时触发</li> <li>onError，小程序发生脚本错误或 API 调用报错时触发</li> <li>onPageNotFound，小程序要打开的页面不存在时触发</li></ul> <p><strong>onLaunch,onShow参数：</strong></p> <ul><li>path：	打开小程序的页面路径</li> <li>query：	打开小程序的页面参数query</li> <li>scene：	打开小程序的场景值，</li> <li>shareTicket：	转发分享参数</li> <li>referrerInfo：当场景为由从另一个小程序或公众号或App打开时，返回此字段</li> <li>referrerInfo.appId：	来源小程序或公众号或App的 appId</li> <li>referrerInfo.extraData： 来源小程序传过来的数据，scene=1037或1038时支持</li></ul> <h3 id="页面生命周期函数"><a href="#页面生命周期函数" aria-hidden="true" class="header-anchor">#</a> 页面生命周期函数</h3> <ul><li>onLoad，监听页面加载</li> <li>onShow, 监听页面显示（如tab切换或者离开微信、或navigateTo）</li> <li>onReady, 监听页面初次渲染完成(一个页面只会调用一次，代表页面已经准备妥当)</li> <li>onHide, 监听页面隐藏, (如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等)</li> <li>onUnload, 监听页面卸载(如wx.redirectTo或wx.navigateBack到其他页面时)</li></ul> <h3 id="组件生命周期函数"><a href="#组件生命周期函数" aria-hidden="true" class="header-anchor">#</a> 组件生命周期函数</h3> <ul><li>created,在组件实例刚刚被创建时执行，注意此时不能调用 setData</li> <li>attached,在组件实例进入页面节点树时执行</li> <li>ready,在组件布局完成后执行</li> <li>moved, 在组件实例被移动到节点树另一个位置时执行</li> <li>detached, 在组件实例被从页面节点树移除时执行</li></ul> <p>注意：</p> <p>组件中存在一个组件所在页面的生命周期，定义在pageLifetimes中，其中可用的生命周期包括：</p> <ul><li>show， 组件所在的页面被展示时执行</li> <li>hide， 组件所在的页面被隐藏时执行</li> <li>resize， 组件所在的页面尺寸变化时执行</li></ul> <h2 id="网络"><a href="#网络" aria-hidden="true" class="header-anchor">#</a> 网络</h2> <ol><li>服务器域名配置，当使用体验版或者开发版报“服务器开小差”了的错误，大部分可能性都是因为没有打开调试，因为在调试模式下，小程序不会去校验域名的合法性。</li> <li>小程序只可以跟指定的域名与进行网络通信，包括普通 HTTPS 请求（wx.request）、上传文件（wx.uploadFile）、下载文件（wx.downloadFile) 和 WebSocket 通信（wx.connectSocket）</li> <li>如果接入第三方网页，使用web-view组件，需要配置业务域名</li> <li>默认超时时间为60s，超时时间可以在 app.json 或 game.json 中通过 networktimeout 配置</li> <li>并发限制：wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个；wx.connectSockt 的最大并发限制是 5 个</li> <li>返回状态，只要成功接收到服务器返回，<strong>无论 statusCode 是多少，都会进入 success 回调</strong></li></ol> <h2 id="自定义tabbar"><a href="#自定义tabbar" aria-hidden="true" class="header-anchor">#</a> 自定义tabBar</h2> <p>用户可以通过配置app.json 中的 tabBar 项指定 custom 字段为true，来自定义tabBar，不过有些使用地方还需要注意：</p> <ol><li>tabBar 的相关配置项仍然需完整声明，以兼容低版本以及区分哪些是tab页</li> <li>需要用户自定义一个组件来渲染 tabBar，推荐用 fixed 在底部的 cover-view + cover-image 组件渲染样式，以保证 tabBar 层级相对较高</li> <li>与 tabBar 样式相关的接口，如 wx.setTabBarItem 等将失效</li> <li>可以在自定义组件下通过 getTabBar 接口，获取当前页面的自定义 tabBar 组件实例</li></ol> <h2 id="小程序登录流程"><a href="#小程序登录流程" aria-hidden="true" class="header-anchor">#</a> 小程序登录流程</h2> <p>小程序登录需要调用微信的开放接口，整体流程如下：</p> <ol><li>小程序通过wx.login()获取一个code</li> <li>调用后端的api，发送code，后端通过这个code来校验接口，并返回一个自定义登录态</li> <li>小程序将登录状态存入storage</li> <li>之后再访问服务器发送业务请求就只用后端判断登录态查询openid和session_key返回业务数据</li></ol> <h2 id="小程序优化操作"><a href="#小程序优化操作" aria-hidden="true" class="header-anchor">#</a> 小程序优化操作</h2> <ol><li>缩短白屏时间：
<ul><li>首屏渲染的内容较多，需要集合多份数据进行渲染：此时可以把优先级高的内容做优先展示</li> <li>首屏内容依赖的数据从服务端请求的时间太长：分析数据返回的时间长的原因</li> <li>一次性渲染数据太大或依赖的计算过于复杂：减少渲染的数据量、优化渲染相关数据的算法</li></ul></li> <li>渲染界面的耗时过长，需要校验下是否同时渲染的区域太大（例如列表过长）</li> <li>脚本执行时间过长：需要确认并优化脚本的逻辑</li> <li>setData调用频繁：避免无用的频繁调用，每秒调用setData的次数不超过 20 次，</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 不要频繁调用setData
    this.setData({ a: 1 })
    this.setData({ b: 2 })
// 绝大多数时候可优化为
    this.setData({ a: 1, b: 2 })
</code></pre></div><ol start="5"><li>setData的数据太大，setData的数据在JSON.stringify后不超过 256KB</li> <li>setData一个未绑定的变量</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外
    this.setData({
      myData: {
        a: '这个字符串在WXML中用到了',
        b: '这个字符串未在WXML中用到，而且它很长…………………………'
      }
    })
    // 可以优化为
    this.setData({
      'myData.a': '这个字符串在WXML中用到了'
    })
    this._myData = {
      b: '这个字符串未在WXML中用到，而且它很长…………………………'
    }

</code></pre></div><ol start="7"><li>开启 HTTP 缓存控制</li> <li>控制WXML节点数</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;view data-my-data=&quot;{{myData}}&quot;&gt; &lt;!-- 这个 view 和下一行的 view 可以合并 --&gt;
  &lt;view class=&quot;my-class&quot; data-my-data=&quot;{{myData}}&quot; bindtap=&quot;onTap&quot;&gt;
    &lt;text&gt; &lt;!-- 这个 text 通常是没必要的 --&gt;
      {{myText}}
    &lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;

&lt;!-- 可以简化为 --&gt;

&lt;view class=&quot;my-class&quot; data-my-data=&quot;{{myData}}&quot; bindtap=&quot;onTap&quot;&gt;
  {{myText}}
&lt;/view&gt;
</code></pre></div><ol start="9"><li>控制图片大小，图片宽高都不超过实际显示宽高的3倍</li> <li>合理控制网络请求数量</li> <li>控制图片请求数</li> <li>开启惯性滚动：wxss中带有overflow: scroll的元素，在 iOS 下需要设置-webkit-overflow-scrolling: touch样式</li> <li>避免使用:active伪类来实现点击态</li> <li>保持图片大小比例</li> <li>可点击元素的宽高都不小于 20px</li> <li>iphoneX兼容，用以下wxss进行兼容：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>padding-bottom: constant(safe-area-inset-bottom);
padding-bottom: env(safe-area-inset-bottom);
</code></pre></div><ol start="17"><li>避免JS异常</li> <li>不使用废弃接口</li> <li>设置最低基础库版本</li> <li>移除不可访问到的页面</li> <li>移除大量未使用的样式</li> <li>及时回收定时器：定时器是全局的，并不是跟页面绑定的，当小程序从一个页面路由到另一个页面之后，前一个页面定时器应注意手动回收</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.db404420.js" defer></script><script src="/blog/assets/js/2.07cc4d7a.js" defer></script><script src="/blog/assets/js/53.124413f8.js" defer></script>
  </body>
</html>
