<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>内置对象 | 空无的博客</title>
    <meta name="description" content="让全栈编程更容易！">
    <link rel="icon" href="favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/blog/assets/css/0.styles.f54d1925.css" as="style"><link rel="preload" href="/blog/assets/js/app.db404420.js" as="script"><link rel="preload" href="/blog/assets/js/2.07cc4d7a.js" as="script"><link rel="preload" href="/blog/assets/js/35.879e924b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.067c6059.js"><link rel="prefetch" href="/blog/assets/js/11.b2e97d2d.js"><link rel="prefetch" href="/blog/assets/js/12.f3b194f5.js"><link rel="prefetch" href="/blog/assets/js/13.1d46fa14.js"><link rel="prefetch" href="/blog/assets/js/14.431e1f9e.js"><link rel="prefetch" href="/blog/assets/js/15.6aab5401.js"><link rel="prefetch" href="/blog/assets/js/16.ce4a82a0.js"><link rel="prefetch" href="/blog/assets/js/17.faa86a5d.js"><link rel="prefetch" href="/blog/assets/js/18.df937046.js"><link rel="prefetch" href="/blog/assets/js/19.7cc79e8b.js"><link rel="prefetch" href="/blog/assets/js/20.88c1806d.js"><link rel="prefetch" href="/blog/assets/js/21.91720da3.js"><link rel="prefetch" href="/blog/assets/js/22.a45ca4e3.js"><link rel="prefetch" href="/blog/assets/js/23.0d1a9424.js"><link rel="prefetch" href="/blog/assets/js/24.f8dc3a1b.js"><link rel="prefetch" href="/blog/assets/js/25.1f6e2fdd.js"><link rel="prefetch" href="/blog/assets/js/26.c3faecd2.js"><link rel="prefetch" href="/blog/assets/js/27.139f423e.js"><link rel="prefetch" href="/blog/assets/js/28.c62a300b.js"><link rel="prefetch" href="/blog/assets/js/29.6d695ea3.js"><link rel="prefetch" href="/blog/assets/js/3.bc263a31.js"><link rel="prefetch" href="/blog/assets/js/30.71890272.js"><link rel="prefetch" href="/blog/assets/js/31.094dc6f8.js"><link rel="prefetch" href="/blog/assets/js/32.28fc139e.js"><link rel="prefetch" href="/blog/assets/js/33.0b875c4b.js"><link rel="prefetch" href="/blog/assets/js/34.966568f6.js"><link rel="prefetch" href="/blog/assets/js/36.e779ed30.js"><link rel="prefetch" href="/blog/assets/js/37.552d42b9.js"><link rel="prefetch" href="/blog/assets/js/38.e752d7eb.js"><link rel="prefetch" href="/blog/assets/js/39.5cfb1c3e.js"><link rel="prefetch" href="/blog/assets/js/4.e2e0255b.js"><link rel="prefetch" href="/blog/assets/js/40.3132f99e.js"><link rel="prefetch" href="/blog/assets/js/41.afd3b019.js"><link rel="prefetch" href="/blog/assets/js/42.b597878a.js"><link rel="prefetch" href="/blog/assets/js/43.422ac91e.js"><link rel="prefetch" href="/blog/assets/js/44.f0595a0f.js"><link rel="prefetch" href="/blog/assets/js/45.1c9c4e5c.js"><link rel="prefetch" href="/blog/assets/js/46.f61c2a6e.js"><link rel="prefetch" href="/blog/assets/js/47.85a2b141.js"><link rel="prefetch" href="/blog/assets/js/48.87d6c131.js"><link rel="prefetch" href="/blog/assets/js/49.06f36298.js"><link rel="prefetch" href="/blog/assets/js/5.c11c6e26.js"><link rel="prefetch" href="/blog/assets/js/50.bdb65770.js"><link rel="prefetch" href="/blog/assets/js/51.e5f04ec9.js"><link rel="prefetch" href="/blog/assets/js/52.abd02c2a.js"><link rel="prefetch" href="/blog/assets/js/53.124413f8.js"><link rel="prefetch" href="/blog/assets/js/54.17d2c69d.js"><link rel="prefetch" href="/blog/assets/js/55.926c3143.js"><link rel="prefetch" href="/blog/assets/js/56.9056faa3.js"><link rel="prefetch" href="/blog/assets/js/57.b580554f.js"><link rel="prefetch" href="/blog/assets/js/58.0fe6c4ff.js"><link rel="prefetch" href="/blog/assets/js/59.c9dedcef.js"><link rel="prefetch" href="/blog/assets/js/6.9e5d8c9e.js"><link rel="prefetch" href="/blog/assets/js/60.7994e946.js"><link rel="prefetch" href="/blog/assets/js/61.40306ba8.js"><link rel="prefetch" href="/blog/assets/js/62.10095560.js"><link rel="prefetch" href="/blog/assets/js/63.98a563bd.js"><link rel="prefetch" href="/blog/assets/js/64.3acac147.js"><link rel="prefetch" href="/blog/assets/js/65.ff6461d6.js"><link rel="prefetch" href="/blog/assets/js/66.3dd6d939.js"><link rel="prefetch" href="/blog/assets/js/67.abe72b05.js"><link rel="prefetch" href="/blog/assets/js/68.901eb929.js"><link rel="prefetch" href="/blog/assets/js/69.555bc92e.js"><link rel="prefetch" href="/blog/assets/js/7.9b93c563.js"><link rel="prefetch" href="/blog/assets/js/70.910023e2.js"><link rel="prefetch" href="/blog/assets/js/71.4e31a5f3.js"><link rel="prefetch" href="/blog/assets/js/72.f04865d2.js"><link rel="prefetch" href="/blog/assets/js/73.d9e0aa1c.js"><link rel="prefetch" href="/blog/assets/js/74.30b717b4.js"><link rel="prefetch" href="/blog/assets/js/75.7a35c8e2.js"><link rel="prefetch" href="/blog/assets/js/76.42220da8.js"><link rel="prefetch" href="/blog/assets/js/8.ab3cc639.js"><link rel="prefetch" href="/blog/assets/js/9.a9f74242.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.f54d1925.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">空无的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/jsGuide/1.html" class="nav-link">JS入门导读</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">JS高级导读</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">全栈入门</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">开发环境配置参考</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">koa+vue全栈开发实战</a></li></ul></div></div><div class="nav-item"><a href="/blog/interview/1.html" class="nav-link">面试宝典</a></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/kongwutw/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">教程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/jsGuide/1.html" class="nav-link">JS入门导读</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">JS高级导读</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">全栈入门</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">JS入门</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">前端进阶</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">实战分享</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">开发环境配置参考</a></li><li class="dropdown-item"><!----> <a href="/blog/share/ssr.html" class="nav-link">vue服务端渲染</a></li><li class="dropdown-item"><!----> <a href="/blog/share/mp.html" class="nav-link">小程序开发总结</a></li><li class="dropdown-item"><!----> <a href="/blog/share/iris.html" class="nav-link">go+vue前后端分离实战</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">uni-app多端开发回顾</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">koa+vue全栈开发实战</a></li></ul></div></div><div class="nav-item"><a href="/blog/interview/1.html" class="nav-link">面试宝典</a></div><div class="nav-item"><a href="/blog/url/fe.html" class="nav-link">常用网址</a></div><div class="nav-item"><a href="https://github.com/kongwutw/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS入门</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js/1.html" class="sidebar-link">基础知识</a></li><li><a href="/blog/js/2.html" class="sidebar-link">数据类型</a></li><li><a href="/blog/js/3.html" class="active sidebar-link">内置对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js/3.html#属性描述对象" class="sidebar-link">属性描述对象</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#object-对象" class="sidebar-link">Object 对象</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#包装对象" class="sidebar-link">包装对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js/3.html#boolean-对象" class="sidebar-link">Boolean 对象</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#number-对象" class="sidebar-link">Number 对象</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#string-对象" class="sidebar-link">String 对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#array-对象" class="sidebar-link">Array 对象</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#json-对象" class="sidebar-link">JSON 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js/3.html#json-stringify" class="sidebar-link">JSON.stringify()</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#json-parse" class="sidebar-link">JSON.parse()</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#set" class="sidebar-link">Set</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#weakset" class="sidebar-link">WeakSet</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#map" class="sidebar-link">Map</a></li><li class="sidebar-sub-header"><a href="/blog/js/3.html#weakmap" class="sidebar-link">WeakMap</a></li></ul></li><li><a href="/blog/js/4.html" class="sidebar-link">函数</a></li><li><a href="/blog/js/5.html" class="sidebar-link">原型与继承</a></li><li><a href="/blog/js/6.html" class="sidebar-link">异步操作</a></li><li><a href="/blog/js/7.html" class="sidebar-link">正则表达式</a></li><li><a href="/blog/js/8.html" class="sidebar-link">Proxy和Reflect</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="内置对象"><a href="#内置对象" aria-hidden="true" class="header-anchor">#</a> 内置对象</h1> <h2 id="属性描述对象"><a href="#属性描述对象" aria-hidden="true" class="header-anchor">#</a> 属性描述对象</h2> <p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等。</p> <p>这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p> <p>Object.getOwnPropertyDescriptor()方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</p> <p>Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p> <p>Object.defineProperty()方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。</p> <p>Object.defineProperty方法接受三个参数，依次如下。</p> <ul><li>object：属性所在的对象</li> <li>propertyName：字符串，表示属性名</li> <li>attributesObject：属性描述对象</li></ul> <p>如果属性已经存在，Object.defineProperty()方法相当于更新该属性的属性描述对象。</p> <p>如果一次性定义或修改多个属性，可以使用Object.defineProperties()方法。</p> <p>如果一个属性的enumerable为false，下面三个操作不会取到该属性。</p> <ul><li>for..in循环</li> <li>Object.keys方法</li> <li>JSON.stringify方法</li></ul> <p>for...in循环包括继承的属性，Object.keys方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用Object.getOwnPropertyNames方法。</p> <p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。</p> <p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。</p> <h2 id="object-对象"><a href="#object-对象" aria-hidden="true" class="header-anchor">#</a> Object 对象</h2> <p>JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。</p> <p>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。</p> <p>Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p> <p>如果参数为空（或者为undefined和null），Object()返回一个空对象。</p> <p>如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例。</p> <p>如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。</p> <p>Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。</p> <p>Object构造函数的首要用途，是直接通过它来生成新对象。</p> <p>Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。</p> <p>Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。</p> <p>对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性。</p> <p>除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。</p> <p>Object实例对象的方法，主要有以下六个。</p> <ul><li>Object.prototype.valueOf()：返回当前对象对应的值。</li> <li>Object.prototype.toString()：返回当前对象对应的字符串形式。</li> <li>Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。</li> <li>Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li> <li>Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。</li> <li>Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。</li></ul> <p>数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。</p> <h2 id="包装对象"><a href="#包装对象" aria-hidden="true" class="header-anchor">#</a> 包装对象</h2> <p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”（wrapper）。</p> <p>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p> <p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。</p> <p>这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</p> <p>valueOf()方法返回包装对象实例对应的原始类型的值。</p> <p>toString()方法返回对应的字符串形式。</p> <p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</p> <h3 id="boolean-对象"><a href="#boolean-对象" aria-hidden="true" class="header-anchor">#</a> Boolean 对象</h3> <p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。</p> <h3 id="number-对象"><a href="#number-对象" aria-hidden="true" class="header-anchor">#</a> Number 对象</h3> <p>Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p> <p>Number对象拥有以下一些静态属性（即直接定义在Number对象上的属性，而不是定义在实例上的属性）。</p> <ul><li>Number.POSITIVE_INFINITY：正的无限，指向Infinity。</li> <li>Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。</li> <li>Number.NaN：表示非数值，指向NaN。</li> <li>Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。</li> <li>Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。</li> <li>Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</li></ul> <p>Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。</p> <p>toFixed()方法先将一个数转为指定位数的小数。</p> <p>toExponential方法用于将一个数转为科学计数法形式。</p> <p>Number.prototype.toPrecision()方法用于将一个数转为指定位数的有效数字。</p> <p>Number.prototype.toLocaleString()方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。</p> <p>与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。</p> <h3 id="string-对象"><a href="#string-对象" aria-hidden="true" class="header-anchor">#</a> String 对象</h3> <p>String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p> <p>String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p> <p>String.prototype.length 字符串实例的length属性返回字符串的长度。</p> <p>charAt方法返回指定位置的字符，参数是从0开始编号的位置。</p> <p>charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。</p> <p>concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p> <p>slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p> <p>substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。</p> <p>substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。</p> <p>indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p> <p>lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。</p> <p>trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p> <p>toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p> <p>match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</p> <p>search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</p> <p>replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</p> <p>split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p> <p>localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</p> <h2 id="array-对象"><a href="#array-对象" aria-hidden="true" class="header-anchor">#</a> Array 对象</h2> <p>Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p> <p>Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p> <p>Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。</p> <p>valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。</p> <p>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p> <p>push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</p> <p>pop方法用于删除数组的最后一个元素，并返回该元素。对空数组使用pop方法，不会报错，而是返回undefined。</p> <p>shift()方法用于删除数组的第一个元素，并返回该元素。shift()方法可以遍历并清空一个数组。</p> <p>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</p> <p>join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p> <p>concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p> <p>reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p> <p>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</p> <p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。</p> <p>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。</p> <p>如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。</p> <p>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回</p> <p>forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。</p> <p>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p> <p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。</p> <p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p> <h2 id="json-对象"><a href="#json-对象" aria-hidden="true" class="header-anchor">#</a> JSON 对象</h2> <p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p> <p>JSON 对值的类型和格式有严格的规定：</p> <ul><li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li> <li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。</li> <li>字符串必须使用双引号表示，不能使用单引号。</li> <li>对象的键名必须放在双引号里面。</li> <li>数组或对象最后一个成员的后面，不能加逗号。</li></ul> <p>JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。</p> <h3 id="json-stringify"><a href="#json-stringify" aria-hidden="true" class="header-anchor">#</a> JSON.stringify()</h3> <p>JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</p> <p>注意，对于原始类型的字符串，转换结果会带双引号。</p> <p>如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。</p> <p>如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。</p> <p>正则对象会被转成空对象。</p> <p>JSON.stringify方法会忽略对象的不可遍历的属性。</p> <p>JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</p> <p>第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。</p> <p>JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</p> <p>如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p> <h3 id="json-parse"><a href="#json-parse" aria-hidden="true" class="header-anchor">#</a> JSON.parse()</h3> <p>JSON.parse方法用于将 JSON 字符串转换成对应的值。</p> <p>如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。</p> <p>为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。</p> <p>JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。</p> <h2 id="set"><a href="#set" aria-hidden="true" class="header-anchor">#</a> Set</h2> <p>它类似于数组，但是成员的值都是唯一的，没有重复的值。</p> <p>Set本身是一个构造函数，用来生成 Set 数据结构。</p> <p>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p> <p>Set 结构的实例有以下属性。</p> <ul><li>Set.prototype.constructor：构造函数，默认就是Set函数。</li> <li>Set.prototype.size：返回Set实例的成员总数。</li></ul> <p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p> <ul><li>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</li> <li>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li> <li>Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。</li> <li>Set.prototype.clear()：清除所有成员，没有返回值。</li></ul> <p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p> <ul><li>Set.prototype.keys()：返回键名的遍历器</li> <li>Set.prototype.values()：返回键值的遍历器</li> <li>Set.prototype.entries()：返回键值对的遍历器</li> <li>Set.prototype.forEach()：使用回调函数遍历每个成员
Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</li></ul> <p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p> <p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。</p> <h2 id="weakset"><a href="#weakset" aria-hidden="true" class="header-anchor">#</a> WeakSet</h2> <p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p> <p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p> <p>WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p> <p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p> <p>WeakSet 没有size属性，没有办法遍历它的成员。</p> <p>WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p> <h2 id="map"><a href="#map" aria-hidden="true" class="header-anchor">#</a> Map</h2> <p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p> <p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p> <p>也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p> <p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p> <p>size属性返回 Map 结构的成员总数。</p> <p>Map.prototype.set(key, value)方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。</p> <p>Map.prototype.get(key)方法读取key对应的键值，如果找不到key，返回undefined。</p> <p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p> <ul><li>Map.prototype.keys()：返回键名的遍历器。</li> <li>Map.prototype.values()：返回键值的遍历器。</li> <li>Map.prototype.entries()：返回所有成员的遍历器。</li> <li>Map.prototype.forEach()：遍历 Map 的所有成员。
需要特别注意的是，Map 的遍历顺序就是插入顺序。</li></ul> <h2 id="weakmap"><a href="#weakmap" aria-hidden="true" class="header-anchor">#</a> WeakMap</h2> <p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。</p> <p>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</p> <p>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</p> <p>如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。WeakMap 的另一个用处是部署私有属性。</p> <p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/js/2.html" class="prev">
          数据类型
        </a></span> <span class="next"><a href="/blog/js/4.html">
          函数
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.db404420.js" defer></script><script src="/blog/assets/js/2.07cc4d7a.js" defer></script><script src="/blog/assets/js/35.879e924b.js" defer></script>
  </body>
</html>
