---
sidebar: auto
collapsable: true
---
从2016年9月21日，微信小程序正式开启内测，我就开始关注和尝试微信小程序的开发，和大多数开发者的感受一样，使用小程序官方的开发方式不是很友好。

同时，支付宝、百度、今日头条和360等公司也陆续推出了自己的小程序，而且有时不仅要支持各种小程序，还要支持h5，或者来回换。

于是，各路大神，为了避免重复乏味的加班搬砖，造了各种框架来简化小程序的开发和提升效率。

## 业界知名方案
已经开源且被广大小程序开发者实践过的小程序多端开发框架就有很多很多，这里简单谈谈比较知名的：目前使用最多的是uni-app，其次是taro，而cml则是最近才开源的，wepy和mpvue目前维护已经不那么活跃了。

### WePY
由腾讯团队推出的小程序组件化开发框架，在开发过程中参考了 Vue 等现有框架的一些语法风格和功能特性，对原生小程序的开发模式进行了再次封装，更贴近于 MVVM 架构模式, 并支持ES6/7的一些新特性。
详情请看：https://wepyjs.github.io/wepy-docs/

### mpvue
美团点评团队出品基于Vue的小程序开发框架，上面的WePY是一个“类Vue”的框架，而这个mpvue是“基于Vue”的框架：因为WePY是在代码开发风格上借鉴了Vue，本身和Vue没有什么关系；而这个mpvue是从整个Vue的核心代码上经过二次开发而形成的一个框架，相当于是给Vue本身赋能，增加了开发微信小程序的能力。
详情请看：http://mpvue.com/

### uni-app
uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。
详情请看：https://uniapp.dcloud.io/

### CML
滴滴在 GitHub 开源的跨端解决方案 Chameleon，简写 CML，通过定义统一的语言框架 + 统一多态协议，从多端（对应多个独立服务）业务中抽离出自成体系、连续性强、可维护强的“前端中台服务”。
详情请看：https://cmljs.org

### Taro 
Taro 是由京东 - 凹凸实验室打造的一套遵循 React 语法规范的多端统一开发框架，通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码。
详情请看：https://taro.aotu.io/

## 技术选型
因为团队成员vue开发经验更丰富，且公司项目基本基于vue, 所有我们只考虑基于vue的小程序开发框架，所以首先排除了taro。

在基于vue的小程序开发框架中，因为mpvue的维护也没有那么积极了，以及cml开源较晚，生态还不够完善，且uni-app 的小程序多端实现是基于mpvue进行二次研发，生态圈庞大，案例较多且相对稳定，所以我们最终选择了uni-app。

至于为何不自己造轮子呢，因为是创业公司，需求较多，且人手不足，即使很想结合cml先进的理念和uni-app丰富的生态进行二次研发，还是心无余力啊！
更多对比请看： https://ask.dcloud.net.cn/article/35867 或 https://juejin.im/post/5c90eb366fb9a070d4199cc9

## 原理分析
Vue.js 和小程序都是典型的逻辑视图层框架，逻辑层和视图层之间的工作方式为：数据变更驱动视图更新；视图交互触发事件，事件响应函数修改数据再次触发视图更新。
![原理图.png](/blog/img/mp.png)

鉴于 Vue.js 和小程序一致的工作原理，我们思考将小程序的功能托管给 Vue.js，在正确的时机将数据变更同步到小程序，从而达到开发小程序的目的。

这样，我们可以将精力聚焦在 Vue.js 上，参照 Vue.js 编写与之对应的小程序代码，小程序负责视图层展示，所有业务逻辑收敛到 Vue.js 中，Vue.js 数据变更后同步到小程序如此一来，我们就获得了以 Vue.js 的方式开发小程序的能力。

Vue代码
- 将小程序页面编写为 Vue.js 实现
- 以 Vue.js 开发规范实现父子组件关联

小程序代码
- 以小程序开发规范编写视图层模板
- 配置生命周期函数，关联数据更新调用
- 将 Vue.js 数据映射为小程序数据模型

并在此基础上，附加如下机制
- Vue.js 实例与小程序 Page 实例建立关联
- 小程序和 Vue.js 生命周期建立映射关系，能在小程序生命周期中触发 Vue.js 生命周期
- 小程序事件建立代理机制，在事件代理函数中触发与之对应的 Vue.js 组件事件响应

Vue.js 视图层渲染由 render 方法完成，同时在内存中维护着一份虚拟 DOM，mpvue 无需使用 Vue.js 完成视图层渲染，因此我们改造了 render 方法，禁止视图层渲染。

生命周期关联：Vue.js 和小程序的数据彼此隔离，各自有不同的更新机制。从生命周期和事件回调函数切入，在 Vue.js 触发数据更新时实现数据同步。小程序通过视图层呈现给用户、通过事件响应用户交互，Vue.js 在后台维护着数据变更和逻辑。

可以看到，数据更新发端于小程序，处理自 Vue.js，Vue.js 数据变更后再同步到小程序。为实现数据同步，修改了 Vue.js runtime 实现，在 Vue.js 的生命周期中增加了更新小程序数据的逻辑。

在每次数据更新的时候，会在Vue监听set方法，每次触发属性更新的时候把当前更新的属性key放在当前V-dom的__keyPath属性中。一次更新全部触发后，在实际render过程中遍历keyPath属性，只选择更新的属性放到json里，调用Page.setData来进行更新操作。同时在Vue.$nextTick函数里，触发完所有的render更新后会清理掉全部keyPath，防止下次再更新又冗余。

事件代理机制：用户交互触发的数据更新通过事件代理机制完成。在 Vue.js 代码中，事件响应函数对应到组件的 method， Vue.js 自动维护了上下文环境。

然而在小程序中并没有类似的机制，又因为 Vue.js 执行环境中维护着一份实时的虚拟 DOM，这与小程序的视图层完全对应，我们思考，在小程序组件节点上触发事件后，只要找到虚拟 DOM 上对应的节点，触发对应的事件不就完成了么；另一方面，Vue.js 事件响应如果触发了数据更新，其生命周期函数更新将自动触发，在此函数上同步更新小程序数据，数据同步也就实现了。

## 如何使用
全局安装vue-cli
```
npm install -g @vue/cli
```
创建uni-app
```
vue create -p dcloudio/uni-preset-vue my-project
```
此时，会提示选择项目模板，选择自定义模板时，需要填写 uni-app 模板地址，这个地址其实就是托管在云端的仓库地址。以 GitHub 为例，地址格式为 userName/repositoryName，如 dcloudio/uni-template-picture 就是下载图片模板。

详情请看：https://uniapp.dcloud.io/quickstart
